<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈树链剖分]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%B5%85%E8%B0%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[引子在OI中，有时候我们会需要处理一些树上的链的问题 比方说，给定一棵$n$个点的树，$m$个操作，每次查询$x$和$y$之间的链上的和 不要在意到底是什么操作，这真的只是个引子 考虑做法。 level 1 $ n,m \leq 100 $ 那么我们直接暴力求即可。复杂度$O(nm)$ level 2 $ n\leq 1000 , m \leq 100000$ 很明显不能直接暴力了。 询问过多，但是并没有修改操作，所以可以考虑$O(n^2)$把$x$和$y$之间的和预处理出来，存起来，直接访问。 level 3 $ n\leq10^5,m\leq10^5$，并且要求支持修改操作 这才是我们今天要讨论的问题 为了支持$O(log^2n)$的修改，$O(log^2n)$的查询，我们发展了这种叫树链剖分的东西。 树链剖分前置芝士 DFS 线段树 链式前向星 定义 重儿子：一个点有多个儿子，定义其儿子中子树大小最大的儿子为重儿子。 轻儿子：一个点不是重儿子的儿子都是轻儿子。 重边：一个点与其重儿子之间的边。 轻边：一个点与其轻儿子之间的边。 重链：完全由重边连成的链。 重链的顶端：一条重链上深度最小（最靠近根）的点。 特别的，我们为了代码的舒适性人为定义一个轻儿子为一条长度为1的重链。 树链剖分能做什么？ 解决一条链上的信息查询/修改问题 其他链上线段树能维护的东西 实现存树这个实际上不难，所有数字直接先丢进线段树的数组，边的话直接读入的时候链式前向星存下来就好。 考虑到是双向边，要加两次。 12345678910111213inline void add(int u,int v)&#123;//链式前向星加边 to[++bian]=v;//记下现在第bian条边所指向的节点 nxt[bian]=beg[u];//指针指向u的链表原来的表头 beg[u]=bian;//更新表头&#125;scanf ("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;r,&amp;mod);//读入fa[r]=0,dep[r]=1;//r是根节点，根节点的父亲是0，深度的1for (int i=1;i&lt;=n;i++)scanf ("%lld",&amp;tree.a[i]);for (int i=1;i&lt;n;i++)&#123; ll a,b; scanf("%lld%lld",&amp;a,&amp;b); add(a,b),add(b,a);&#125; 两遍DFS第一遍DFS这遍DFS要处理出以下的信息： 一个点的深度$d$ 一个点的重儿子$s$ 一个点的父亲$f$ 一个点的子树大小（含自己）$siz$ 代码： 1234567891011inline void dfs1(int x)&#123; siz[x]=1;//初始大小是1（只有自己） for (int i=beg[x];i;i=nxt[i])&#123;//访问x的所有出边 if (to[i]==fa[x])continue;//到父亲的边，不考虑 fa[to[i]]=x;//访问到的节点的父亲是x dep[to[i]]=dep[x]+1;//深度是x+1 dfs1(to[i]);//向访问到的节点DFS siz[x]+=siz[to[i]];//加上儿子的子树大小 if (siz[to[i]]&gt;siz[son[x]])son[x]=to[i];//更新重儿子的信息 &#125;&#125; 第二遍DFS在第一遍DFS的基础上，我们现在知道了每个点的子树大小（包括自己），重儿子等信息。 接下来就是树链剖分的核心了： 把一棵树按照轻重边剖分成若干条链，剖分的过程就是第二遍DFS 至于剖分的原因，后面在证明复杂度的时候会说 具体实现： 我们对每个点重标号，使得一条重链上的点的标号是连续的，然后对重标号后的点建线段树 第二遍DFS需要处理这些内容： 记录下每个点的新标号 把这个点的值赋到新标号上（之后建线段树要用） 记录下每个点所在的重链的顶端 代码： 12345678inline void dfs2(int x,int y)&#123; top[x]=y;id[x]=++tot;num[tot]=x;//记录下x所在的重链的顶端y，同时为新标号赋值 if (son[x])dfs2(son[x],y);//优先DFSx的重儿子，这样保证一条重链上的点的标号是连续的 for (int i=beg[x];i;i=nxt[i])&#123; if (to[i]==fa[x]||to[i]==son[x])continue; dfs2(to[i],to[i]);//DFS剩下的轻儿子 &#125;&#125; 处理敲黑板：重点来了！也许你不清楚前文提到的两边DFS的意义，这里会有解释 我们进行了第二遍DFS之后，得到了一下的结果： 由于我们DFS时优先考虑重儿子，这样每条重链上的点的新标号是连续的 由于是DFS，每棵子树的新标号是连续的 链的查询/修改有了上文，本来链上的问题变成了统计若干条重链加轻边的问题。 查询和修改的思路实际上很相似，都是两个点分别向上跳，直到在同一条重链上为止，最后直接统计一次重链上两个点之间的和。 既然重链上的新标号的连续的，那么我们就可以用线段树维护每条重链的和，这样重链的查询就是$O(logn)$的了。 至于轻边，我们可以直接暴力累加，但由于我们人为定义了每个轻儿子是一条长度为1的重链，所以实际上写代码的时候可以和重链的查询合并。 修改的代码： 12345678910void chge(int x,int y,int k)&#123; k%=mod; while (top[x]!=top[y])&#123;//使用类似倍增求LCA的思想，每次找深度大的点往上跳 if (dep[top[x]]&lt;dep[top[y]])swap(x,y);//保证x的深度大 tree.change(1,id[top[x]],id[x],1,n,k);//直接统计x所在的重链的和，这条重链的起点是x所在的重链的顶端的新标号，终点是x的新标号 x=fa[top[x]];//直接跳到x所在重链顶端的父亲，保证不重复统计 &#125;//把两个点跳到同一条重链上 if (dep[x]&lt;dep[y])swap(x,y); tree.change(1,id[y],id[x],1,n,k);//最后处理重链上两个点之间的部分&#125; 查询的代码： 1234567891011int query(int x,int y)&#123; int ans=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]])swap(x,y);//同样是选深度大的向上跳 ans=(ans+tree.ask(1,id[top[x]],id[x],1,n))%mod; x=fa[top[x]]; &#125; if (dep[x]&lt;dep[y])swap(x,y); ans=(ans+tree.ask(1,id[y],id[x],1,n))%mod;//也是最后处理同一条重链上x和y之间的部分 return ans;&#125; 实际上很像，只是把线段树的修改换成了查询而已。 子树的修改/查询既然有了一棵子树的新标号的连续的保证，那么原来的一棵子树实际上对应着线段树中的一段连续区间。 那么直接线段树区间修改/查询就好。而且由于是连续区间，那么$x$的子树的起点必然是$x$的新标号，终点必然是$x$的新标号$+x$的子树大小再$-1$。 那么代码就很简单了： 修改： 1tree.change(1,id[x],id[x]+siz[x]-1,1,n,k) 查询： 1tree.ask(1,id[x],id[x]+siz[x]-1,1,n) 复杂度简单证明当树为二叉树的时候，深度最大。 一棵树总共有$n$个点，由于一个点$x$的重儿子起码占了$x$的子树大小的一半，那么每次递归下去节点个数都减半，很明显$logn$次就能结束。 这里特殊的是链的情况，然而整棵树上有一大部分是链的时候，显然他们必然连成若干条重链，而不可能都是轻边，那么对我们的复杂度并不构成巨大的影响。 所以重链的数量$\leq logn$。 又因为每两条重链之间必然由轻边分割（不然就连成一条重链了），所以轻边的数量同样$\leq logn$。 于是树链剖分做到了对于一条链上的查询/修改，$O(log^2n)$的复杂度。 很是优秀了。 完整代码实际上讲到这里应该都会写了吧（雾，但为了讲清楚一些细节还是给一下吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;const int N=100005;#define ll long longint dep[N],siz[N],fa[N],z[N],to[N&lt;&lt;1],beg[N&lt;&lt;1],nxt[N&lt;&lt;1],top[N&lt;&lt;2],bian,son[N&lt;&lt;1],id[N&lt;&lt;1],tot,n,m,r,mod,num[N];struct Tree&#123; ll ans[N&lt;&lt;2],tag[N&lt;&lt;2],a[N]; inline ll lson(ll p)&#123;return p&lt;&lt;1;&#125; inline ll rson(ll p)&#123;return (p&lt;&lt;1)|1;&#125; inline void push_up(ll p)&#123;ans[p]=(ans[lson(p)]+ans[rson(p)])%mod;&#125; inline void build(ll p,ll l,ll r)&#123; if (l==r)&#123;ans[p]=a[num[l]];return ;&#125; ll mid=(l+r)&gt;&gt;1; build(lson(p),l,mid); build(rson(p),mid+1,r); push_up(p); tag[p]=0; &#125; inline void lazy_tag(ll p,ll l,ll r,ll k)&#123;ans[p]=(ans[p]+(r-l+1)*k)%mod,tag[p]=(tag[p]+k)%mod;&#125; inline void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; lazy_tag(lson(p),l,mid,tag[p]); lazy_tag(rson(p),mid+1,r,tag[p]); tag[p]=0; &#125; inline void change(ll p,ll nl,ll nr,ll l,ll r,ll k)&#123;//nl,nr-&gt;changing l,changing r;l,r-&gt;visiting l,visiting r if (nl&lt;=l&amp;&amp;nr&gt;=r)&#123;ans[p]=(ans[p]+(r-l+1)*k)%mod,tag[p]=(tag[p]+k)%mod;return ;&#125; ll mid=(l+r)&gt;&gt;1; push_down(p,l,r); if (nl&lt;=mid)change(lson(p),nl,nr,l,mid,k); if (nr&gt;mid)change(rson(p),nl,nr,mid+1,r,k); push_up(p); &#125; inline ll ask(ll p,ll nl,ll nr,ll l,ll r)&#123; if (nl&lt;=l&amp;&amp;nr&gt;=r)return ans[p]; ll mid=(l+r)&gt;&gt;1,res=0; push_down(p,l,r); if (nl&lt;=mid)res=(res+ask(lson(p),nl,nr,l,mid))%mod; if (nr&gt;mid)res=(res+ask(rson(p),nl,nr,mid+1,r))%mod; return res; &#125;&#125;tree;//之前封装好的线段树inline void add(int u,int v)&#123;//链式前向星加边 to[++bian]=v; nxt[bian]=beg[u]; beg[u]=bian;&#125;inline void dfs1(int x)&#123;//第一遍dfs，之前已经详细讲过 siz[x]=1; for (int i=beg[x];i;i=nxt[i])&#123; if (to[i]==fa[x])continue; fa[to[i]]=x; dep[to[i]]=dep[x]+1; dfs1(to[i]); siz[x]+=siz[to[i]]; if (siz[to[i]]&gt;siz[son[x]])son[x]=to[i]; &#125;&#125;inline void dfs2(int x,int y)&#123;//同上 top[x]=y;id[x]=++tot;num[tot]=x; if (son[x])dfs2(son[x],y); for (int i=beg[x];i;i=nxt[i])&#123; if (to[i]==fa[x]||to[i]==son[x])continue; dfs2(to[i],to[i]); &#125;&#125;int query(int x,int y)&#123;//链的查询，也讲过了 int ans=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]])swap(x,y); ans=(ans+tree.ask(1,id[top[x]],id[x],1,n))%mod; x=fa[top[x]]; &#125; if (dep[x]&lt;dep[y])swap(x,y); ans=(ans+tree.ask(1,id[y],id[x],1,n))%mod; return ans;&#125;void chge(int x,int y,int k)&#123;//链的修改 k%=mod; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]])swap(x,y); tree.change(1,id[top[x]],id[x],1,n,k); x=fa[top[x]]; &#125; if (dep[x]&lt;dep[y])swap(x,y); tree.change(1,id[y],id[x],1,n,k);&#125;int main()&#123; scanf ("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;r,&amp;mod);fa[r]=0,dep[r]=1; for (int i=1;i&lt;=n;i++)scanf ("%lld",&amp;tree.a[i]); for (int i=1;i&lt;n;i++)&#123; ll a,b; scanf("%lld%lld",&amp;a,&amp;b); add(a,b),add(b,a); &#125; dfs1(r);//从根节点开始 dfs2(r,r);//同上，根节点必然是根所在的重链的顶端 tree.build(1,1,n);//对于我们重标号之后的数组，建线段树 while(m--)&#123; ll flag,x,y,k; scanf ("%lld",&amp;flag); switch (flag)&#123; case 1:scanf ("%lld%lld%lld",&amp;x,&amp;y,&amp;k);chge(x,y,k);break;//链上修改 case 2:scanf ("%lld%lld",&amp;x,&amp;y);printf("%lld\n",query(x,y));break;//链上查询 case 3:scanf ("%lld%lld",&amp;x,&amp;k);tree.change(1,id[x],id[x]+siz[x]-1,1,n,k);break;//子树修改 case 4:scanf ("%lld",&amp;x);printf("%lld\n",tree.ask(1,id[x],id[x]+siz[x]-1,1,n));//子树查询 &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1207F 【Remainder Problem】]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%A2%98%E8%A7%A3-CF1207F-%E3%80%90Remainder-Problem%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题其实有原题的……参见P3396 看到$500000$的数据范围想必大家也有感觉，$O(n^2)$的暴力可以不用考虑了……要是您能n方过百万那么当我没说 然而我们又是对每次%一个数之后的一些数进行操作，所以线段树/树状数组也不太好维护 您能写出来那是我太弱，Orz 有没有什么方法能快速解决这些关于%的问题的呢？ 联想到分块，分块的本质就是对于每个数%之后放进相对应的块中，然后大的直接统计，小的直接暴力。而且$O(\sqrt{n})$的算法复杂度，也是可以承受的。 那么我们就可以采用基于分块的思想解决这个问题了。 于是代码就呼之欲出了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;int m,opt,x,y;#define ll long longll ans[710][710],a[500005];const int n=500000;struct control&#123; int ct,val; control(int Ct,int Val=-1):ct(Ct),val(Val)&#123;&#125; inline control operator()(int Val) &#123; return control(ct,Val); &#125;&#125;_endl(0),_prs(1),_setprecision(2);struct FastIO&#123; #define IOSIZE 1000000 char in[IOSIZE],*p,*pp,out[IOSIZE],*q,*qq,ch[20],*t,b,K,prs; FastIO():p(in),pp(in),q(out),qq(out+IOSIZE),t(ch),b(1),K(6)&#123;&#125; ~FastIO()&#123;fwrite(out,1,q-out,stdout);&#125; inline char getch() &#123; return p==pp&amp;&amp;(pp=(p=in)+fread(in,1,IOSIZE,stdin),p==pp)?b=0,EOF:*p++; &#125; inline void putch(char x) &#123; q==qq&amp;&amp;(fwrite(out,1,q-out,stdout),q=out),*q++=x; &#125; inline void puts(const char str[])&#123;fwrite(out,1,q-out,stdout),fwrite(str,1,strlen(str),stdout),q=out;&#125; inline void getline(string&amp; s) &#123; s=""; for(register char ch;(ch=getch())!='\n'&amp;&amp;b;)s+=ch; &#125; #define indef(T) inline FastIO&amp; operator&gt;&gt;(T&amp; x)\ &#123;\ x=0;register char f=0,ch;\ while(!isdigit(ch=getch())&amp;&amp;b)f|=ch=='-';\ while(isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getch();\ return x=f?-x:x,*this;\ &#125; indef(int) indef(long long) inline FastIO&amp; operator&gt;&gt;(char&amp; ch)&#123;return ch=getch(),*this;&#125; inline FastIO&amp; operator&gt;&gt;(string&amp; s) &#123; s="";register char ch; while(isspace(ch=getch())&amp;&amp;b); while(!isspace(ch)&amp;&amp;b)s+=ch,ch=getch(); return *this; &#125; inline FastIO&amp; operator&gt;&gt;(double&amp; x) &#123; x=0;register char f=0,ch; double d=0.1; while(!isdigit(ch=getch())&amp;&amp;b)f|=(ch=='-'); while(isdigit(ch))x=x*10+(ch^48),ch=getch(); if(ch=='.')while(isdigit(ch=getch()))x+=d*(ch^48),d*=0.1; return x=f?-x:x,*this; &#125; #define outdef(_T) inline FastIO&amp; operator&lt;&lt;(_T x)\ &#123;\ !x&amp;&amp;(putch('0'),0),x&lt;0&amp;&amp;(putch('-'),x=-x);\ while(x)*t++=x%10+48,x/=10;\ while(t!=ch)*q++=*--t;\ return *this;\ &#125; outdef(int) outdef(long long) inline FastIO&amp; operator&lt;&lt;(char ch)&#123;return putch(ch),*this;&#125; inline FastIO&amp; operator&lt;&lt;(const char str[])&#123;return puts(str),*this;&#125; inline FastIO&amp; operator&lt;&lt;(const string&amp; s)&#123;return puts(s.c_str()),*this;&#125; inline FastIO&amp; operator&lt;&lt;(double x) &#123; register int k=0; this-&gt;operator&lt;&lt;(int(x)); putch('.'); x-=int(x); prs&amp;&amp;(x+=5*pow(10,-K-1)); while(k&lt;K)putch(int(x*=10)^48),x-=int(x),++k; return *this; &#125; inline FastIO&amp; operator&lt;&lt;(const control&amp; cl) &#123; switch(cl.ct) &#123; case 0:putch('\n');break; case 1:prs=cl.val;break; case 2:K=cl.val;break; &#125; &#125; inline operator bool()&#123;return b;&#125;&#125;io;int main()&#123; io&gt;&gt;m; int sz=sqrt(n);//每个块的大小 while (m--)&#123; io&gt;&gt;opt&gt;&gt;x&gt;&gt;y; if (opt==2)&#123; if (x&lt;=sz)io&lt;&lt;ans[x][y]&lt;&lt;"\n";//可以直接进行的查询操作，直接输出 else&#123; ll sum=0; for (int i=y;i&lt;=n;i+=x)sum+=a[i]; io&lt;&lt;sum&lt;&lt;"\n";//否则暴力解决 &#125; &#125; else if (opt==1)&#123; for (int p=1;p&lt;=sz;p++)ans[p][x%p]+=y;//把修改x会产生影响的块的值都更新 a[x]+=y;//然后更新原数组 &#125; &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1207C 【Gas Pipeline】]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%A2%98%E8%A7%A3-CF1207C-%E3%80%90Gas-Pipeline%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题就是裸的dp，然而我还是莫名其妙手残打错了一次。 思路：对于每个位置，我们令$f[i][0]$为到达$i$时高度为$1$的最小答案，$f[i][1]$为到达$i$时高度为$2$的最小答案，分情况讨论之后dp： 是路口 那么$i$位置高度不能为$0$，反映在dp上就是$f[i][0]=inf$ 我们对$f[i][1]$取$min$：看是从上一个位置下来再上来便宜，还是直接拉过来便宜。 不是路口 那么$f[i][0]$就是对从上一个位置下来和直接平的过来取$min$ $f[i][1]$同是路口的情况，也是分上来和直接平行过来取$min$。 代码： 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,k;string s;#define ll long long#define inf 884888488848997//注意！inf要开大！不然会WA的QAQll a,b,f[200005][2];int main()&#123; ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;s; memset(f,0,sizeof(f)); f[0][1]=inf;f[0][0]=a+b; for (int i=1;i&lt;s.size();i++)&#123; k=(s[i]=='1'); if(k)&#123;//是路口 f[i][0]=inf; f[i][1]=min(f[i-1][0]+2*a+2*b,f[i-1][1]+2*b+a);//从f[i-1][0]和f[i-1][1]转移 &#125;else&#123; f[i][0]=min(f[i-1][0]+a+b,f[i-1][1]+2*a+2*b); f[i][1]=min(f[i-1][0]+2*a+b,f[i-1][1]+2*b+a);//同上，思路已经说过了 &#125; &#125; cout&lt;&lt;f[n-1][0]+b&lt;&lt;endl;//输出答案的时候要注意，最后要求高度降为1，而且1的高度也是需要柱子的 &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1207B 【Square Filling】]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%A2%98%E8%A7%A3-CF1207B-%E3%80%90Square-Filling%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题实际上就是裸的暴力……然而我仍然在WA了3次，有一次还是样例WA了 思路：既然题目没有要求操作次数最少，那么我们能操作的地方就操作一次，这样最后没有被操作到的就只能是无法操作的地方了。 细节看代码： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;bool a[55][55],b[55][55];vector&lt;pair&lt;int,int&gt; &gt; ans;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)scanf("%d",&amp;a[i][j]); for (int i=1;i&lt;n;i++) for (int j=1;j&lt;m;j++)if(a[i][j]&amp;&amp;a[i+1][j]&amp;&amp;a[i][j+1]&amp;&amp;a[i+1][j+1])ans.push_back(make_pair(i,j)),b[i][j]=b[i+1][j]=b[i][j+1]=b[i+1][j+1]=1;//如果a[i][j]、a[i][j+1]、a[i+1][j]和a[i+1][j+1]都为1的话我们才能在(i,j)操作一次，更新b for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)if(b[i][j]^a[i][j])return !printf("-1");//如果a和b有不一样的地方那肯定就是无解了 printf("%d\n",ans.size()); for (vector&lt;pair&lt;int,int&gt; &gt;::iterator it=ans.begin();it!=ans.end();it++)printf("%d %d\n",it-&gt;first,it-&gt;second);//输出&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1207A 【There Are Two Types Of Burgers】]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%A2%98%E8%A7%A3-CF1207A-%E3%80%90There-Are-Two-Types-Of-Burgers%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题有两个简单的做法：贪心和暴力 我这里介绍一下暴力的做法 我们对于鸡肉和牛肉进行枚举，如果是可行的情况就更新答案 具体看代码吧： 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int t;long long b,p,f,h,c;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; cin&gt;&gt;b&gt;&gt;p&gt;&gt;f&gt;&gt;h&gt;&gt;c; long long ans=0; for (int i=0;i&lt;=p;i++) for (int j=0;j&lt;=f;j++)if(((i+j)*2)&lt;=b)ans=max(ans,i*h+j*c);//如果(i+j)*2&lt;=b表示面包够用，则这是一种可能的情况，可以更新答案 //注意！一定要从0开始！一开始就是这里没注意结果直接在#2WA了两次 cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1204C 【Anna, Svyatoslav and Maps】]]></title>
    <url>%2F2019%2F08%2F21%2F%E9%A2%98%E8%A7%A3-CF1204C-%E3%80%90Anna-Svyatoslav-and-Maps%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题其实还是挺简单的，但我还是想了很久而且还被hack了一次 思路：floyd+two-pointer+贪心 先floyd预处理出所有点之间的最短路，然后对于每个i找最靠后的j，满足$dis[p[i]][p[j+1]]&gt;=dis[i][j]+1$，即由p[i]到p[j+1]的最短路必过p[j] 然后把退出循环的p[j]塞进答案数组，因为这个p[j]必须要去一次。 代码： `cpp #include &lt;bits/stdc++.h&gt;using namespace std;int n,m,p[1000005],a[105][105];char x;vector ans;int main(){ ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); cin&gt;&gt;n; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++)a[i][j]=1926817;//初始化 for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++){ cin&gt;&gt;x; if(x==’1’)a[i][j]=1;//读入图 } for (int i=1;i&lt;=n;i++)a[i][i]=0; for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++)a[i][j]=min(a[i][j],a[i][k]+a[k][j]);//Floyd求最短路 cin&gt;&gt;m; for (int i=1;i&lt;=m;i++)cin&gt;&gt;p[i]; int i=1,j=2;ans.push_back(p[1]);//p[1]是必到的 for (;i&lt;=m&amp;&amp;j&lt;=m;){ while(j&lt;m&amp;&amp;a[p[i]][p[j+1]]&gt;=a[p[i]][p[j]]+1)j++;//j&lt;m保证了下标不越界，我们要找能满足p[i]到p[j+1]的最短路必过p[j]的最后一个j ans.push_back(p[i=j++]);//p[j]要停一次，不然的话可能下一次最短路不过p[j] } cout&lt;&lt;ans.size()&lt;&lt;endl; for (vector::iterator it=ans.begin();it!=ans.end();it++)cout&lt;&lt;*it&lt;&lt;’ ‘;//输出}]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1204B 【Mislove Has Lost an Array】]]></title>
    <url>%2F2019%2F08%2F21%2F%E9%A2%98%E8%A7%A3-CF1204B-%E3%80%90Mislove-Has-Lost-an-Array%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题实际上就是贪心 思路：先取2的0到l-1次方，保证至少有l个不同的数，算出基本答案； 然后对于最小的答案，剩下的n-l个数全部填1，对于最大的答案，我们补全2的r-1次方，然后对于剩下的n-r个数全部填$2^{r-1}$ 代码： 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,l,r,cnt=1,ansn,ansx;//注意，防爆intint main()&#123; cin&gt;&gt;n&gt;&gt;l&gt;&gt;r; for (int i=1;i&lt;=l;i++)ansn+=cnt,cnt*=2; ansx=ansn,ansn+=n-l;//计算出基本答案后直接算出最小答案 for (int i=l+1;i&lt;=r;i++)ansx+=cnt,cnt*=2; cnt/=2; ansx+=(n-r)*cnt;//补上n-r个数 cout&lt;&lt;ansn&lt;&lt;' '&lt;&lt;ansx;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1204A 【BowWow and the Timetable】]]></title>
    <url>%2F2019%2F08%2F21%2F%E9%A2%98%E8%A7%A3-CF1204A-%E3%80%90BowWow-and-the-Timetable%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题有数论写法，但赛场上与其花不少时间推柿子还不如直接暴力 具体看代码吧 123456789101112n=int(input()) # 读入ni=1ans=0while n&gt;0: if n%2==1: ans+=i i*=2 n=n//10 # 手动转十进制，注意由于给出的就是二进制而我们存成了10进制，所以每次/10才能去掉最后一位k=0while 4**k&lt;ans: k+=1 # 枚举print(k)]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1206A 【Choose Two Numbers】]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%A2%98%E8%A7%A3-CF1206A-%E3%80%90Choose-Two-Numbers%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实完全可以桶解决 具体看代码吧 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[105],b[105];bool s[505];//桶，因为a,b&lt;=200，所以和实际上&lt;=400int main()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),s[a[i]]=1;//丢进桶 scanf("%d",&amp;m); for (int i=1;i&lt;=m;i++)scanf("%d",&amp;b[i]),s[b[i]]=1;//丢进桶*2 for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)if(!s[a[i]+b[j]])return !printf("%d %d",a[i],b[j]);//枚举，在a和b中各选一个，利用桶判有没有出现过&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1205A/1206C 【Almost-Equal】]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%A2%98%E8%A7%A3-CF1205A-1206C-%E3%80%90Almost-Equal%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这个题就是个结论题=-= 然而我比赛的时候还是想了0.5h，还RE了一次 我们观察到在环上，相对的两个数差为1。 这意味着我们的每次递推必然产生两个数，于是很不自然的想到%2。 接下来就是大胆猜想不用证明的部分了： 观察样例，发现当$n=1$时，则填出的数列为$1,2$，所以可以猜想枚举的过程中$i$&amp;$1$的话则$a_{n+i}=a_i+1$ 既然$i$&amp;$1$时为$a_{n+i}=a_i+1$，那么为了平衡，另一种情况我们就另$a_i=a_{n+i}+1$ 观察到样例给出的$n=4$是无解的，手动画图发现$n=2$也是无解的，于是大胆猜想$n$为偶数时都无解。 事实上以上的3条猜想都是正确的。 证明：我们既然要相隔$n$的两个数相差$1$，但是相邻数之和尽可能接近，易证小数和大数间隔放是一种可行策略，而且当$n$为偶数时不满足。 好像我的证明过程一样没啥卵用 于是给出代码： 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[200005],cnt;int main()&#123; scanf("%d",&amp;n); if(!(n&amp;1))return !printf("NO"); puts("YES"); for (int i=1;i&lt;=n;i++)if(i&amp;1)a[i]=++cnt,a[i+n]=++cnt; else a[i+n]=++cnt,a[i]=++cnt; for (int i=1;i&lt;=n*2;i++)printf("%d ",a[i]);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1206B 【Make Product Equal One】]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%A2%98%E8%A7%A3-CF1206B-%E3%80%90Make-Product-Equal-One%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题实际上就是一个不是很裸的贪心 然而我比赛时还是WA了2次 这个首先要注意的是，要开long long； 至于思路，很明显，&lt;0的我们全部改成-1，&gt;0的全部改成1，0统计数量，最后把所有的±1乘起来，如果有0的话则是不用管是不是1的，因为可以通过修改一个0来达到把-1变成1；否则的话要把其中一个-1变为1，即再加上2的答案。 代码： 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int n,s=1,cntz;long long ans,a[100005];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n; for (int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i]&lt;0)ans+=-1-a[i],a[i]=-1;//&lt;0的变成-1 else if(a[i]==0)ans++;//=0的肯定是要动1次的 else ans+=a[i]-1,a[i]=1;//&gt;0的改成1 &#125; for (int i=1;i&lt;=n;i++)if(a[i])s*=a[i];else cntz++;//统计乘积和0的个数 if(s==-1&amp;&amp;!cntz)ans+=2;//如果乘起来是-1，又没有可以动手脚的0，则要把其中一个-1改为1，再额外加上2 cout&lt;&lt;ans;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP11814 【EKO - Eko】]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-SP11814-%E3%80%90EKO-Eko%E3%80%91%2F</url>
    <content type="text"><![CDATA[康了一下题解相当不详细啊…… 这个题是裸的二分答案 直接用代码讲吧 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int n,m;//n-&gt;N,m-&gt;Mlong long a[1000005],ans;//注意！每个数≤1000000000，会爆int（所以我们其实可以hack掉@炸毛的龙猫 的题解）inline bool check(long long d)&#123; long long cnt=0; for (int i=1;i&lt;=n;i++)cnt+=max(a[i]-d,(long long)0); return cnt&gt;=m;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); long long l=1,r=0,mid;//敲黑板：三年OI一场空，不开long long见祖宗 for (int i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]),r=max(r,a[i]);//很明显下界是1，上界我们定一个最大值 while(l&lt;=r)&#123;//有可能的区间 mid=(l+r)&gt;&gt;1; if (check(mid))ans=max(ans,mid),l=mid+1;//mid是一个可行的答案，那么可能的区间上调，同时更新答案 else r=mid-1;//否则可能的区间下调 &#125; printf("%lld",ans);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1200B 【Block Adventure】]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-CF1200B-%E3%80%90Block-Adventure%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题实际上就是个贪心……题意我交了翻译，这里就不重复说了 很明显，由于包的容量是无限大的，所以我们只要能往包里塞砖块就往里面塞，因为多塞肯定不吃亏 于是得到贪心策略：能把当前的砖能拿的尽量拿走，如果高度不够补到打擦边球…… 具体看代码吧 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int t,n,m,k,h[105];int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for (int i=1;i&lt;=n;i++)scanf("%d",&amp;h[i]); bool flag=1;//判断是否有解 for (int now=1;now&lt;n&amp;&amp;flag;now++)&#123; if (h[now]&gt;=h[now+1]-k)m+=min(h[now]-h[now+1]+k,h[now]);//能拿则多拿，但注意只能拿空，不能那成负的\滑稽 else m-=h[now+1]-h[now]-k,h[now]=h[now+1]-k;//高度不够则补到刚好可以跳过去 if (m&lt;0)flag=0;//砖头用完了都跳不过去，则肯定无解 &#125; puts(flag?"YES":"NO"); &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF580E 【Kefa and Watch】]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-CF580E-%E3%80%90Kefa-and-Watch%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题目其实很简单啊……看了一下题解基本上都做烦了，一个memcmp的水题，怎么还用到了什么线段树维护哈希？开玩笑。。。 注意到所有数字都在0~9之间，于是可以考虑把放在字符数组里，然后每次更新直接memcpy，查询memcmp。 然后就结束了？ 上代码。 12345678910111213#include&lt;bits/stdc++.h&gt;char s[100100];int main()&#123; int n,m,k,l,r,c,i,f; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;k,s+1);//读入初始序列：直接转成char m+=k; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d",&amp;f,&amp;l,&amp;r,&amp;c); if(f==1) memset(s+l,c+'0',r-l+1);//修改 else puts(memcmp(s+l,s+l+c,r-l-c+1)?"NO":"YES");//查询 //哪有那么烦？ &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF312A 【Whose sentence is it?】]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-CF312A-%E3%80%90Whose-sentence-is-it-%E3%80%91%2F</url>
    <content type="text"><![CDATA[额，这题居然没有C++的题解。 分析： 字符串基本操作，没啥好说的，直接模拟即可。读入整个字符串，判断后5位即可。 代码： 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; char a[105]; scanf("%d",&amp;n); getchar(); while(n--)&#123; cin.getline(a,105); int len=strlen(a); if(a[len-1]=='.'&amp;&amp;a[len-2]=='a'&amp;&amp;a[len-3]=='l'&amp;&amp;a[len-4]=='a'&amp;&amp;a[len-5]=='l')//分类：以lala结尾 if(a[0]=='m'&amp;&amp;a[1]=='i'&amp;&amp;a[2]=='a'&amp;&amp;a[3]=='o'&amp;&amp;a[4]=='.')printf("OMG&gt;.&lt; I don't know!\n");//如果又有miao，就不知道是谁说的了 else printf("Freda's\n");//否则输出Freda's else if(a[0]=='m'&amp;&amp;a[1]=='i'&amp;&amp;a[2]=='a'&amp;&amp;a[3]=='o'&amp;&amp;a[4]=='.')//以miao开头 if(a[len-1]=='.'&amp;&amp;a[len-2]=='a'&amp;&amp;a[len-3]=='l'&amp;&amp;a[len-4]=='a'&amp;&amp;a[len-5]=='l')printf("OMG&gt;.&lt; I don't know!\n");//同理，如果又有lala，就不知道是谁的了 else printf("Rainbow's\n"); else printf("OMG&gt;.&lt; I don't know!\n"); &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF317A 【Perfect Pair】]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-CF317A-%E3%80%90Perfect-Pair%E3%80%91%2F</url>
    <content type="text"><![CDATA[讲道理，这个题其实真没什么好说的，就是直接模拟 基本思路很简单：每次挑小的换成和。 具体看代码吧 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long llint;llint x,y,m,ans;int main()&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;m; if (x&gt;=m||y&gt;=m)&#123; puts("0"); return 0; &#125;//如果直接符合，直接输出 if (x&lt;=0&amp;&amp;y&lt;=0)&#123; puts("-1"); return 0; &#125;//如果x、y都负，则不可能变成完美 if (x&gt;y)swap(x,y);//如果x比y大，换一下 if (x&lt;0)&#123; ans+=(-x)/y; x+=(-x)/y*y; &#125;//如果有个负的，想办法把他弄成正的（方法：始终加y） while(x&lt;m&amp;&amp;y&lt;m)&#123; if (x&gt;y) swap(x,y); x+=y; ans++; &#125;//模拟 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5497 【[LnOI2019SP]龟速单项式变换(SMT)】]]></title>
    <url>%2F2019%2F08%2F14%2F%E9%A2%98%E8%A7%A3-P5497-%E3%80%90-LnOI2019SP-%E9%BE%9F%E9%80%9F%E5%8D%95%E9%A1%B9%E5%BC%8F%E5%8F%98%E6%8D%A2-SMT-%E3%80%91%2F</url>
    <content type="text"><![CDATA[QAQ我比赛的时候居然煞笔了没想出正解…… 我比赛的时候不想动脑子，这样打的： 123#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;puts("YES");&#125; 70。。。 其实，大家想一下，如果$n&lt;m$，则肯定能构造一组数据，因为$x%m$的余数就有$m-1$种，所以必然能构造出一组数据。 于是得出结论1： $n&lt;m$时，答案为NO 那么我们可以大胆猜想，不用证明，$n≥m$时一定就是YES了 好吧我们来证一下 根据抽屉原理，当$n≥m$时，必然有一个余数出现了2次 设这两个余数相同的数分别为$x_i,x_j$，可以以$x_i$为一个元素构造出一个“司$m$序列”，于是有： $$ (sum_{1}+x_i)-(sum_{2}+x_j)\equiv 0(mod m) $$ 进一步： $$ sum_{1}+x_i\equiv sum_{2}+x_j (mod m) $$ 又因为 $$ x_i\equiv x_j (mod m)$$ 所以 $$ sum_{2}\equiv 0(mod m) $$ 于是可以针对$x_j$构造出一个“司$m$序列”。 命题得证。 于是得到结论： $n&lt;m$时，答案为NO；否则为YES 代码就不贴了，讲的这么清楚了应该都能自己写出来]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1801 【黑匣子_NOI导刊2010提高（06）】]]></title>
    <url>%2F2019%2F08%2F06%2F%E9%A2%98%E8%A7%A3-P1801-%E3%80%90%E9%BB%91%E5%8C%A3%E5%AD%90-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%EF%BC%8806%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到这个题面，不断加入元素，每次查询第k大，我就立刻想到了平衡树…… 然后又不会手码，于是想到了pbds的tree 然后就轻松的码出了30分的代码…… 问了别人才知道原来有重复元素，而且pbds的tree是不能插入重复元素的 那么，我们怎么解决呢？ 我想到了hash。 我们对每个元素维护一个二元组$\left(x,h\right)$，$x$表示元素本来的值，而$h$是我们通过hash搞出的一个唯一的随机值。 然后对每个u把没加进tree的元素加进去，然后直接利用tree求kth。 代码： 123456789101112131415161718192021222324252627282930// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#include &lt;bits/extc++.h&gt;using namespace std;using namespace __gnu_pbds;struct User&#123; int x,h; inline bool operator &lt; (const User&amp;p)const&#123;return x!=p.x?x&lt;p.x:h&lt;p.h;&#125;&#125;a[200005];//我们的二元组，注意，一定要满足单升，即：必须对任意两个元素的大小定义死tree&lt;User,null_type,less&lt;User&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; t;//定义一个pbds的红黑树map&lt;int,bool&gt; mp;//判断一个hash值是否出现过了int m,n,i,u[200005],last=1,hh;inline int Hash(int x)&#123; while(mp[x])x=x+rand(); return x;&#125;//对每个x生成一个唯一的值hint main()&#123; scanf("%d%d",&amp;m,&amp;n); for (int j=1;j&lt;=m;j++)&#123; scanf("%d",&amp;a[j].x); hh=Hash(a[j].x); a[j].h=hh,mp[hh]=1; &#125;//读入的同时预处理好每个二元组 for (int j=1;j&lt;=n;j++)scanf("%d",&amp;u[j]);//读入的u实际上已经拍好序了 for (int j=1;j&lt;=n;j++)&#123; for (;last&lt;=u[j];last++)t.insert(a[last]);//插♂入 printf("%d\n",(*t.find_by_order(i++)).x);//直接查kth，返回的是地址，我们要先取*再加. //注意！tree中查第k个元素实际上是find_by_order(k-1) &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睡前读物：我为何而OI]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%9D%A1%E5%89%8D%E8%AF%BB%E7%89%A9%EF%BC%9A%E6%88%91%E4%B8%BA%E4%BD%95%E8%80%8COI%2F</url>
    <content type="text"><![CDATA[为了获得最佳的阅读体验，请在睡前阅读 有时候，我会莫名思考一些事情，于是有了这篇口胡的文章。 前言我为何而OI？ 我不清楚。 但我知道，我搞OI 我也应该去搞OI 哪怕没有别人的帮助 哪怕一个人孤独 我 注定OI OI黑历史为了您的阅读体验，本部分使用上帝视角。 四年级/2014四年级那个暑假，我爸问我： 你喜欢电脑吗？喜欢。那你叫你妈带你去市里报名。哦。 然后我就去市里报了名，然后参加了市里组织的免费的logo班，然后碰到了我的几个同学，然后就开始入坑logo，然后不停的考试，考试，考试。最后我愣是考进了最后的班…… 怎么全都是然后 五年级/2015当时在某市的计算机水平考试之前，我像疯了一样的搞补全程序，然后不知道的去问老师 我老师奇怪的问我： 你研究这个干啥 我抬起头，很无语的说 拿分啊。 于是在最后一次考试中，我考进了某市的小C班。 并且得知我是某区唯一一个考进去的。 后来我才知道小C招不算6年级的rk前50，logo提高班招算6年级的rk前100 于是我不算6年级rk50，算6年级rk100 这擦边球打的真™好 其实能成为某区唯一一个进小C班的人不是因为我有多强，有很大一部分原因是因为这个区没有初中搞OI，没前途。 然而当时的我怎么会知道这些？ 反正，尽力吧，既然选择了，那么爬也要走完。 六年级/2016进了小C班，认识了现在OI上的一批朋友。 记得第一次课的时候，老师让我们上去写一个判断奇偶的程序。 然后我上去了，写下了一个老师没看懂的东西。 老师教了10年小C，然后我写了一个用TEST实现的logo。 不知道TEST是什么的请自行百度 看来我的想法奇怪是有传统的 然后就跟在后面很认真的学，学了1年去打NOIP2016。 当时那个激动啊。。。 过了初赛，感觉自己真是个人才。 那个时候连爆搜都不会，冲上去打了T1T2，然后回去相当开心。 丝毫没有意识到T2会TLE 于是测出来165，拿了个省二。 其实165已经过了PJ1=分数线了，只是因为ah人太多被挤出去了 并参加了AHOI2016的小学组，T3傻逼一样的dp没打出来，省二回去滚粗了。 暑假里出了第一道题：洛谷P4907 这个暑假快活，天天颓废，刷题，算是最快活的日子了。 初一/2017初一或许算我OI历史最多的一年？ 先是以为某个众所周知的原因进了某所并不重视OI的学校。报名的时候，我把我的市三好学生、NOIP省二等等奖状一摆，招生处的老师说：你这个情况，我们会在会议上优先讨论。 没说出来的意思是：你进某个重点班基本上是稳了。 于是等到分班考试的时候，我极其淡定，三张卷子全部做完了。 监考老师看我的表情一脸懵逼：你又做完了？ 23333333 其实我的分数过了所有3个重点班的分数线 然后开始了在这个学校的OI征程…… 本来学校说要请老师辅导我们，然而我反正没看到 最搞笑的是我们生物老师什么都不懂，非要来插一杠子，讲我们班同学都可以去参加一下初赛试试，然后被我怼了回去，劝我们班同学别白送钱给CCF。 之后我们生物老师就再也没有在我们班提过这个事儿了 幸亏我之后的生物考试成绩不是rk1就是rk2，不然估计我会死的很惨 报着保2冲1的心态，我去考了NOIP2017。 还好，考的还不错，拿了个省一。 后来的AHOI2018考的就很差了，只拿了两个省三，还被班主任教育了一顿 然后初一的日子，就这么溜走了。 初二/2018初二的历史就比较少了 由于从第一次月考一来，我的文化课一直在下滑，而且一直没有突破第一次月考的成绩，家长要求我如果初二再下滑的话要停OI了。 人家停文化课搞OI，我停OI搞文化课 然后我当时就很火大，老子尽力了好吧h7ggNKl2于是月考rk58-&gt;期中rk20-&gt;期末rk3 家长终于不说话了。 不过，由于自己学习的问题，而且也不想打省赛了，AHOI2019就没有参加。 然后去打了NOIP2018，拿了一个很差的省一回来。 初三后记有时候，我都在想，我到底是为了什么而OI？ 肯定不是为了兴趣。 如果是为了兴趣，我绝不可能专注于C++，而应该更多关注Java和Python这些更实用的语言。 而且上一次我写个程序测试生命游戏，我妈问我，你研究这个东西对你学电脑有帮助吗？ 我能怎么回答？ 我只能说，没有。 然后我妈说，那你想好了，你时间不多。 我默然。 尽管我父母认同我学OI是为了兴趣，但没说出来的话是，要是搞OI对学业一点帮助都没有，又怎么可能让我放心搞OI？ 但我学OI不是为了兴趣又是为了什么？ 我在一个不在乎OI的学校一个人孤独的搞OI，那种感觉不好的。 人，就是这么纠结。想为了自己所爱的东西而奋斗，却从不曾拜托生活的控制。 只能说，我入坑OI，是偶然，更是必然。 时代的潮流将我推入OI的大坑，而我甘心爬不出来。 我不后悔。 不忘初心，继续前进。 然而我学OI的初心究竟是为了什么？ 我希望，我的OI，是为了兴趣，而不是为了升学。 时代导致为兴趣而学的人很少，当家长看到我拿省一时，羡慕的说，你可以去签约了。 我只能惨然的笑笑。大多数人都为了升学而学，把OI当成一种工具，一种升学手段，而不是一种生活方式。在这种学校，又有谁能理解我？ 孤独。 进入初三，我大概率要AFO一年了，因为对于我来说，中考仍是我唯一的出路。 写这篇文章，不是为了改变什么，你我都知道，我也不可能改变什么。 我是为了记住，曾经的我，为了什么而学OI。 也希望正在阅读这篇文章的你，也能清楚的知道自己为何而OI。 我希望，当然也希望你，若干年之后，仍能骄傲的说 我为了兴趣而OI。 这，或许就算是我OI的初心吧。 仰望星空，脚踏实地。 OI剩下来的路，如果我没办法陪你走，你也要坚持走下去。 自己选的路，就要坚持到底。 再见，或许再也不见。 祝您OI一帆风顺，也祝我还有机会重返OI。 再见吧。 Updated on 2019.8.27 21:04.]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1335 【[NOI2013]小Q的修炼】]]></title>
    <url>%2F2019%2F07%2F29%2F%E9%A2%98%E8%A7%A3-P1335-%E3%80%90-NOI2013-%E5%B0%8FQ%E7%9A%84%E4%BF%AE%E7%82%BC%E3%80%91%2F</url>
    <content type="text"><![CDATA[by dblark，目前只写了标准答案 P1335 [NOI2013]小Q的修炼题解 Case 1:点击显/隐 12341111 Case 2:点击显/隐 123456789101112131415161718192021222324251121212112121111221111211 Case 3:点击显/隐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200012111111112211122111111111212221111221111122121122211211212122111212122211111222121211111211222111112122112111221221111112111212111112121121211221121122111111221111111221122111112112111112212111112121111112121111112112112112212111222111111121112111222111111111111211122112211121111121111211112112121121221121111111112122212212111111111111112112112112221122111121111121221112211121111112211211111121111112111111211111111121111111111112112121111111112211211211111211111112112122111211221111112211111111112112111212121221111211211211111111211111211211112121111121111121112111121112122111111222221121111111111111111121112122111112111212111121111121221211112112111211212112221211111112211111122111211112111111211121121111112121111111112111112112111112221211112111211212111122122211111111111121211122112121112211121211122111121111112111111112121112111111111211121121112111111111112212122111121221111222111211121212111121222111111122211121211111121112112111111121111211212111111112111112112111121121111111212111111211221121111221211211211112111211221211111121112111212112111211121112211112121111112121211112111212121111121111111112112122211111221111111211111121111112112212111112212112111211212211111111111112112121111211122211111121122211111111211112211111112111121211112211211211111212221122112221112222212122211111122112212121111111212111212121112111211121111211111121121112122121211212221112112111212121211111111121212122112111211111112221121211121111111112211111112112111221111111121121111111122111211222111121121212211111111212111111111112211211121121222112111112111122122211112211111221112111121221111121111211111112111111111121211111112212211112111122211112211112211111211112211111111112121121111121122121111111121112221111121211121121112122211122111211111122112112111211111211211112121121111111111211111111121112111111112212121111212211111111221121121121122111222111121212121211121111111112122121111211211111111121222111111112221112112111211121121112212121212121211111112121211211112112111112122111 Case 4:点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999221111121211211121121211221121111212212112122121112222111122211121111222111122212112111121112222221122221222112221211111221121112111211212212121122112211121211112221112122112212121112211211112112112212122112122212112112211221222112121221111121112212122122121122112212211111222121111111111211221112112111121121221111111121212112111112112211111121212122221122221211111221121211111221121221112211121211112111212211221112211211212211111211112212211121211111222212212222112121121111211111111121221122112111221121112111221111211212122222221211111212111121111111111222121121121111112221112111211212112212212112112222112121222212211221211222111122211111221222221221121222212122121111122212121221212212111112221222211112111222112111122112121121121222221111111121212212221111111111122112221112212212211112121212211222122211112121212211111121211211212221111211112111212112222211122121121111222221121212111122111122112121222121122111111221221112111222211121221112221211211111111211122122112112211221112112122111 Case 5:点击显/隐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318321112112121111212121112211112111222211112211221212111212112111211221112121211111112121221112121211112112111211122121121211211112211121122121212211212211212221211111211112111122122121112111111121121121121111211112112111211112112112121221112211221221211212121111221212122111122112111121111212121122121212111221121122112122111111111121111111211121211211112112111112122111211122112121111112112111121211112112111111111111112121112111211221212112112121121112111111112111111211111211111111111121111112211111211211211111121211122211111121212111212121111212212111111111112211122111112111111212221121121111121121122111112211211112112211111112121212212112111121221121212111112211211111121112111112211211211211112112111122121111121111121212121111111111211111212112111111112122211121122212121211121121212111111122112121111211111111121211121211111 Case 6:点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614121211121122111211222221222111211111121112122111111111212112112111111111111111211121211211111211111111211122211111111111122121111111111111122221121111111121112212111211121122111121211221111121211111111211211111211211211211121112121112111211111121121211211221121121211211121221111111111211111121211221111122121222221121121111211212112111112121111111121122211111211121121111211112112111111112111211111121111121121112111111121121211111121112111121211111111212221112111111121212221212211111111121111112121112111221121212112121121121111112222121211212112211111211112121111212112211221111121211211122112212111121222121221211111111211112121112121122121112212111121121111121112111121121212211111111111112111111112112111212112111121111122112212111121121121111111111211111111211112111121211121211111211111121221211111211211111111211112121111211211111211221212111222122112111211212111111222111112211111121111112112121111111111111212112112111211111212111121111122112111212112211111211122212111112121112112211222121121211121112111121121121122111211121211111111121211211111111121111111111111121112122111111111111221211211111211122111111112121211122221121112211211112121121112112111211112111121111112111122211111111112112111111121122111212111111112111122112111211111112121221111122112121112111212121112111121111111111111221111112121122111121122212112111112112111121111111111111111122112111111221212112112121112211121112111121121221121111111211121112111221122121112121212112221111111211222111112112111111111111211211111111111111212111121111112111111211121211112112211212121211112121121112121221111111111212112211121111111111112121 Case 7:点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708211111111121111212111211121121222122111112221111112111111121221111221121121121121112111121112111111121221121111212111221111112111121121211111211121211121112121212121121111111122112121122111111211121111111222121211211111212121111111111111121111212211112112112111111211111112111221221121112212211112112111222111111111111111211211221222212111111121111112121111221111111121111111112121221112111122111212211121111111122122111121111111211111121211111121111111111122112221212211211111111111221111211212111111111111111211121111211211112111211112112111222121121111211112212111222211211121111222211221121111212111112111111221111211112121111112112211111122112111111211222111112111111111111121122121112211111112212111111 Case 8:点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560111121122112211112211121212111112122121112111111111121111221111111121111111122111111211221221122212111111121112122211121121111121121111111112111211112211111121211111111122111112211112211211122111111112122111112121111111111112111111121212112121212211111222211121121111211112111111121111222221111121211121122112121112111112122212111111211111112121121211211121112111112212111111221111112112211122111111221111121111211122111112111211112112221112121221111111221212121121121121111112122112111111222211112212212211111212112222211111221111111121211111211112111221121112121112121111111112111212111121111221122111111121111112111111111211111211111211221211122111112112211121121111122111122211122221112211122121121221121121211112111112111121112111112112121111212111112112111211211121111111221111112111121122112122121211221111211111121221111111211112112121112111121221121111111211112112111121111121211111212211111121111212121111222111112121111121221121111111112122111111222121221111111111121121122112111111122222211111211111111111112111121111121111122112111222111111112211211112122121211121212111111112112121121112121111112111211122211211211212211111112211111121111111121112121221111211111112111112212121111111111122111211111111111211111112222111121211221111212111221211221222121111121121111121111122111112211121111111112212121212122111122112112111211122121111111212122211111211112211112112111121112111111121122111111111121111112211211122111111111111111111121211111211121111111112211112111111121112112121111222111121111121112111112111121121112111112121212121211112111111121 Case 9:点击显/隐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387391211111112111122111112112221112111111122112111211112211111111111112112122122111211111111111112112211211111111111111212211121211211111122112112111111111221211212212121112111211112111112112111211111112212112112111121211111111211211112121221111121222121211211111121212111111111111221211121111112111121211121111221111221211111122112211121211121211121111211212121111111221212111112111111121221112112111111221211112121211212111111121121112221211211221112111121111111121112111111121221121211112112212111211111111211211111121111111111111122211121111122211111211111121111212211112111222111121212111212112121111212121211111111122112121122111111212122111122211111122111111211121111212112111121121122212112111111111112111111122211111212111111111112211 Case 10:点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344112111122111121121112111112112121112121111111111111222222111211212211111111121221122111111111111121122121211221112211122111111211121111212212111111111112112211211121111111122111111222121211221211121111212112112211111211121211112211111212111111111222121111111112211111111112112111222111121211111111111211212211121111121122112121121111112112111221212111221112111122211111211211122121121111112111211111211111211111221111111211112111111121121111112111211121111111211222112112112111112111112221211121211121121211112111121112121111112111111221111121112121112111221111111122111211211112112112121121121212111111122111112111112111112111211211111111111111111121112111121222112112111211211121121111221111111112122211211121111212211111222111111121121212111111122111112112111121211112121222111111212111121111111212111222111122111211111111112212111121111211111212121111121111212111121111121111112211122111121222212111121211111111121211111222112111211211112111112111112111111122111211211111111211121112211212211211121211111111121111211121111111121211211111121111111111111211111121122112111211111211212112211111111111111112212211121211212121122112111122111111111211121111111111121122121212111111111121112221112112111211111212121121121211112111111222121111211211211111212121112111211111111121112112211111211111112221111112211121121111111211122212112111211121111]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某谷讲师语录]]></title>
    <url>%2F2019%2F07%2F16%2F%E6%9F%90%E8%B0%B7%E8%AE%B2%E5%B8%88%E8%AF%AD%E5%BD%95%2F</url>
    <content type="text"><![CDATA[RT. zzy(Created_equal1) 我* 太有毒了 那我就当是我说的了 你会发现这个a[2]特别牛* 麻将个锤子 怎么“lòng” 你们一说上过了我就好慌 先容我喝一口水 怎么又要推笔记啊 我学艺不精 三分钟很长 粗鄙之语，不足于耳啊 我来在线丢人了 我跟楼叉楼很熟的 我有毒 有点丢人 给我幼小的心灵沉重的打击 我也觉得不要对CCF抱太大期望 Scarlet 显然 我没上过小学 妈呀这个人好臭啊 毒瘤代码 毒瘤码风了解一下 大胆假设，谨慎证明 一看就是对的对不对 哎呀，这里怎么没有加空格 这个N_D好强啊 如果翻车的话会扣工资啊，还不如都写了 看过这道题的都快毕业了 啊？正解？ 我们是再看一集呢，还是再看一集呢 等下，这个不显然吧 我选择手写，耶 代码草稿两开花 我设出来的啊 在线抖腿 笑死我了，nmd 到这里地球人应该都会了 噢，这还可以删的 讲完这个就可以下课了……嗬，有道理，那我证吧！ 我cao 杰哥不要啊 你们怎么这么颓废啊 我们来看一下为什么e[j]=e[j] Excuse me ? 少儿…… 我好害怕 太cao了 Oh yeah~ 算了，我自闭了 Lucas没前途了 那我只能羡慕 那我还是复读一遍吧 (N_D)是强，是真的强 这有一道**题诶 康托展开让我康康 你们照顾老年选手 滚 有毒吧 （提问：N_D能AKIOI吗）能 （N_D提问：老师我能爆零吗）我能，你可能不能 我艹 这人比我强多了 krydom 完了我感觉我会丢人啊 很多人都说读题很重要，我说读错题也很重要啊 唉，不读题 真的WA了，为什么，为什么？？ 很多时候错只是因为不读题啊，你知道吗 。。。你们别听我说读错题也很重要那句话啊，忘掉忘掉 （某人提问：我有lxl女装照）这谁没有啊 will是真的帅，我觉得他是江苏省选级别最帅的了 师娘的照片？不给！我怎么可能给你呢 你知道吗我们说话她都能听得见的 你们不要恶意消费lxl了，他已经很可怜了 对，lxl在修大坝 我现在和lxl是真正意义上的同学了 什么？lxl来了？ 欸~我把lxl禁言了 唉这个lxl有点过分啊，算了我们妥协一下 我怎么可能wa呢，这种水题我还是随便切的好吧 丢人本身并不是件丢人的事情对吧 NOIP2018提高组第一天就是考你会不会写代码，你觉得呢 我花了30分钟AK 我问能不能提前离场，得到答复是不能，于是我就开始玩扫雷，扫啊扫啊 扫累了睡一会儿睡一会儿 然后我就开始玩蜘蛛纸牌，但是玩了两关玩死了，我死活玩不过去，但是扫雷还是非常好玩的对吧 我一看题？？？？算了，扫雷去了 众所周知ysy咕咕咕，他鸽子王 sky在上课吧，我就可以尽情占他便宜了 sky的父亲叫krydom 这个地球人都知道是二分 垃圾清华，毁我青春 算了算了不唱了，丢人啊，kkk，剪掉啊 （某人提问：你和师娘是不是下午要看电影）没有啊 （接上面）啊是是是，你怎么知道的？ 新宝岛？好啊放吧放吧 傻逼导师 （某人提问：老师你怎么有那么多车） 什么叫有那么多年，听不懂 使劲优化 师娘漂不漂亮？当然漂亮啦，我敢说她不漂亮吗 谁教教我左对齐怎么写啊 我相信在座的一定有不会写左对齐的对不对，一定有的 周易不是孔子编写的吗？我觉得你在骗我！ 完了小学学一元二次方程了吗，我好慌啊 你学的根本不是真正的数学 可恶的sky 我感觉我好能扯啊 要坚信自己的程序没问题 （某人提问：lxl是不是小姐姐？）lxl是大哥哥 完了我感觉我要被lxl禁言了 lxl要暴政了，你们赶紧去推翻他的暴政 随便ac （一个名叫Toxic先生的人在提问区里发奇怪的东西）我记得Toxic是有毒的吧，这位有毒先生，请不要在提问区里发有毒的东西了 完了被你们发现我在干什么了 上课玩steam? 那你很牛逼 这玩意不是给你们做的 cfdiv2的题，那我不高兴看了，太水了 仓鼠肉很好吃啊 对不起，没有猫和老鼠 对，我也去修大坝了 清华真是垃圾学校，连我这种垃圾都招 那你可以去睡大觉了 睡懒觉人之天性嘛 zcy当然吊打集训队了 我为什么搜颈椎病治疗了呢，因为最近我颈椎非常痛，这充分说明了高三对人的压迫 呵，我一战成名 我对了，他挂了 在线切黑题，那不是sky吗 别让我看YnOI啊 lxl毒瘤的一批 数据结构会把人学傻，你看看那个lxl]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5315 【头像上传】]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%A2%98%E8%A7%A3-P5315-%E3%80%90%E5%A4%B4%E5%83%8F%E4%B8%8A%E4%BC%A0%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题就是标准的模拟 上来先把所有图的大小搞成&lt;=G 然后判是不是&gt;=L 然后输出就好 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;long long n,l,g,w,h;int main()&#123; scanf ("%lld%lld%lld",&amp;n,&amp;l,&amp;g);//读入，long long防卡 while (n--)&#123; scanf ("%lld%lld",&amp;w,&amp;h); while (w&gt;g||h&gt;g)w&gt;&gt;=1,h&gt;&gt;=1;//如果有一条边长了，两边一起减半 if (w&lt;l||h&lt;l)&#123;puts("Too Young");continue;&#125;//小了，输出 if (w!=h)&#123;puts("Too Simple");continue;&#125;//不是正方形，输出 puts("Sometimes Naive");//否则没问题 &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF493A 【Vasya and Football】]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%A2%98%E8%A7%A3-CF493A-%E3%80%90Vasya-and-Football%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实就是模拟 题目大意：已知有两个球队home和away，现在给出一些足球运动员被黄牌或红牌警告的时间，求每个队员第一次被红牌警告的时间。（2张黄牌会自动变成1张红牌） 已经描述的很清楚了。 具体看代码吧 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int max_n=111;int n,f[2][max_n];string a[2];int main()&#123; cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;n;//读入2个队的名字和总被罚次数 while(n--)&#123; int t,num,q,c; char c1,c2; cin&gt;&gt;t&gt;&gt;c1&gt;&gt;num&gt;&gt;c2;//读入被罚的队、队员编号、红牌还是黄牌和时间 if(c1=='h')q=0; else q=1;//q=0-&gt;home队 if(c2=='y')c=1; else c=2;//保证一张红牌抵两张红牌 if(f[q][num]&lt;2)&#123;//如果之前没被罚下去 f[q][num]+=c;//加上本次的惩罚 if(f[q][num]&gt;=2)cout&lt;&lt;a[q]&lt;&lt;" "&lt;&lt;num&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;//如果本次被罚到红牌了，再见 &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF201A 【Clear Symmetry】]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%A2%98%E8%A7%A3-CF201A-%E3%80%90Clear-Symmetry%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题目其实很简单 一个(2*i+1)*(2*i+1)的对称矩阵最多容纳的1的数量=((2*i+1)*(2*i+1)+1)/2 答案就是2*i+1 所以暴力即可。 特别的，当i=3时，由于边长为5的矩阵比较神奇，可以有多种排法，所以特判一下i=3时输出5。 代码就不贴了]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF168A 【Wizards and Demonstration】]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%A2%98%E8%A7%A3-CF168A-%E3%80%90Wizards-and-Demonstration%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题目是真的入门 然而我还是WA了几次 坑点是一个上取整和精度问题 首先我们设答案为$ans$,最小答案为$ans_{min}$，则有$ ans+x \ge n*y\%$ 所以$ans_{min}=n*y\%-x$ 为了上取整，我们输出$n/100.0*y+0.99-x$，于是由于精度问题被卡了 所以我们只好输出$(n*y+99)/100-x$，然后就AC了 代码： 1234567#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,x,y; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y; cout&lt;&lt;max((n*y+99)/100-x,0);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF224A 【Parallelepiped】]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%A2%98%E8%A7%A3-CF224A-%E3%80%90Parallelepiped%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题目其实连暴力都不用，题意基本上就是给定$ x=ab,y=bc,z=ca $，求$ 4*(a+b+c) $ 我们令$ s=xyz $，则$ s=abbcca=a^{2}b^{2}c^{2} $ 所以$ sqrt(s)=abc $ 所以用$ sqrt(s)/x,sqrt(s)/y,sqrt(s)/z $即可求出三边 代码： 123456789#include &lt;bits/stdc++.h&gt;using namespace std;long long a,b,c,s;int main()&#123; scanf ("%lld%lld%lld",&amp;a,&amp;b,&amp;c); s=a*b*c; s=sqrt(s); cout&lt;&lt;4*(s/a+s/b+s/c);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF887B 【Cubes for Masha】]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%A2%98%E8%A7%A3-CF887B-%E3%80%90Cubes-for-Masha%E3%80%91%2F</url>
    <content type="text"><![CDATA[看了一下题解很麻烦，我来一发简单的 这题很明显可以直接离散化，每6个数一组，$ O(n^2) $暴力枚举，如果不在一组就进行标记。 程序非常简单。 12345678910#include &lt;bits/stdc++.h&gt;using namespace std ;int a[20],n,i=1;bool v[300];//标记出现了没有int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;6*n;i++)&#123;cin&gt;&gt;a[i];v[a[i]]=1;&#125;//读入，初始标记 for(int i=0;i&lt;6*n;i++)for(int j=0;j&lt;6*n;j++)if((i!=j)&amp;&amp;((i/6)!=(j/6)))v[a[i]+10*a[j]]=1;//直接暴力枚举拼方块 while(v[i++]);cout&lt;&lt;i-2;//因为退出循环的时候i已经++过了，所以要-2&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1043C 【Smallest Word】]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%A2%98%E8%A7%A3-CF1043C-%E3%80%90Smallest-Word%E3%80%91%2F</url>
    <content type="text"><![CDATA[不得不说py3有的时候是真的强 这个题目py3有专用命令zip…… zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。 12s=input()print(*(int(x!=y)for x,y in zip(s,s[1:]+'b')))//直接强行命令]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF341E 【Candies Game】]]></title>
    <url>%2F2019%2F03%2F17%2F%E9%A2%98%E8%A7%A3-CF341E-%E3%80%90Candies-Game%E3%80%91%2F</url>
    <content type="text"><![CDATA[这个题目实际上就是一个贪心 注意到合并的原则是当$ a_{i} \leq a_{j} $时才能合并，所以我们必须把小的先合并了，不然到后面越合并越大，小的就并不了了。 代码： 12345678910111213141516171819#include&lt;cstdio&gt;#define swap(x,y) x^=y^=x^=y#define set(x) ans1[++m]=p1,ans2[m]=x,a[x]-=a[p1],a[p1]&lt;&lt;=1int i,j,n,m,p1,p2,p3,a[1001],ans1[100000],ans2[100000];int main()&#123; scanf("%d",&amp;n); for(i=1;i&lt;=n;scanf("%d",a+i++)); for(p2=1,p3=2,i=3;i&lt;=n;++i) for(p1=i;;)&#123; if(a[p1]&gt;a[p2])swap(p1,p2); if(a[p2]&gt;a[p3])swap(p2,p3); if(a[p1]&gt;a[p2])swap(p1,p2);//交换，保证顺序 if(a[p1]==0)break;//空了 for(j=a[p2]/a[p1];j;j&gt;&gt;=1)if(j&amp;1)set(p2);else set(p3);//模拟合并 &#125; if((a[p1]==0)+(a[p2]==0)+(a[p3]==0)!=1)puts("-1");//判断不可行 else for(printf("%d\n",m),i=1;i&lt;=m;++i)printf("%d %d\n",ans1[i],ans2[i]);//输出 return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真正的IO优化]]></title>
    <url>%2F2019%2F03%2F17%2F%E7%9C%9F%E6%AD%A3%E7%9A%84IO%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[RT 点击显/隐 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788struct control&#123; int ct,val; control(int Ct,int Val=-1):ct(Ct),val(Val)&#123;&#125; inline control operator()(int Val) &#123; return control(ct,Val); &#125;&#125;_endl(0),_prs(1),_setprecision(2);struct FastIO&#123; #define IOSIZE 1000000 char in[IOSIZE],*p,*pp,out[IOSIZE],*q,*qq,ch[20],*t,b,K,prs; FastIO():p(in),pp(in),q(out),qq(out+IOSIZE),t(ch),b(1),K(6)&#123;&#125; ~FastIO()&#123;fwrite(out,1,q-out,stdout);&#125; inline char getch() &#123; return p==pp&amp;&amp;(pp=(p=in)+fread(in,1,IOSIZE,stdin),p==pp)?b=0,EOF:*p++; &#125; inline void putch(char x) &#123; q==qq&amp;&amp;(fwrite(out,1,q-out,stdout),q=out),*q++=x; &#125; inline void puts(const char str[])&#123;fwrite(out,1,q-out,stdout),fwrite(str,1,strlen(str),stdout),q=out;&#125; inline void getline(string&amp; s) &#123; s=""; for(register char ch;(ch=getch())!='\n'&amp;&amp;b;)s+=ch; &#125; #define indef(T) inline FastIO&amp; operator&gt;&gt;(T&amp; x)\ &#123;\ x=0;register char f=0,ch;\ while(!isdigit(ch=getch())&amp;&amp;b)f|=ch=='-';\ while(isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getch();\ return x=f?-x:x,*this;\ &#125; indef(int) indef(long long) inline FastIO&amp; operator&gt;&gt;(char&amp; ch)&#123;return ch=getch(),*this;&#125; inline FastIO&amp; operator&gt;&gt;(string&amp; s) &#123; s="";register char ch; while(isspace(ch=getch())&amp;&amp;b); while(!isspace(ch)&amp;&amp;b)s+=ch,ch=getch(); return *this; &#125; inline FastIO&amp; operator&gt;&gt;(double&amp; x) &#123; x=0;register char f=0,ch; double d=0.1; while(!isdigit(ch=getch())&amp;&amp;b)f|=(ch=='-'); while(isdigit(ch))x=x*10+(ch^48),ch=getch(); if(ch=='.')while(isdigit(ch=getch()))x+=d*(ch^48),d*=0.1; return x=f?-x:x,*this; &#125; #define outdef(_T) inline FastIO&amp; operator&lt;&lt;(_T x)\ &#123;\ !x&amp;&amp;(putch('0'),0),x&lt;0&amp;&amp;(putch('-'),x=-x);\ while(x)*t++=x%10+48,x/=10;\ while(t!=ch)*q++=*--t;\ return *this;\ &#125; outdef(int) outdef(long long) inline FastIO&amp; operator&lt;&lt;(char ch)&#123;return putch(ch),*this;&#125; inline FastIO&amp; operator&lt;&lt;(const char str[])&#123;return puts(str),*this;&#125; inline FastIO&amp; operator&lt;&lt;(const string&amp; s)&#123;return puts(s.c_str()),*this;&#125; inline FastIO&amp; operator&lt;&lt;(double x) &#123; register int k=0; this-&gt;operator&lt;&lt;(int(x)); putch('.'); x-=int(x); prs&amp;&amp;(x+=5*pow(10,-K-1)); while(k&lt;K)putch(int(x*=10)^48),x-=int(x),++k; return *this; &#125; inline FastIO&amp; operator&lt;&lt;(const control&amp; cl) &#123; switch(cl.ct) &#123; case 0:putch('\n');break; case 1:prs=cl.val;break; case 2:K=cl.val;break; &#125; &#125; inline operator bool()&#123;return b;&#125;&#125;io;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[我收集的模板，希望对大家能有所帮助 常用优化点击显/隐 12345678910#pragma comment(linker, "/STACK:102400000,102400000") //扩系统栈#pragma GCC diagnostic error "-std=c++14" //暴力开C++14#pragma GCC optimize ("O3") //开O3#pragma GCC -mcmodle=large //开巨型数组不RE(编译时间变长)std::ios::sync_with_stdio(false); //cin/coutcin.tie(0); #define min(x,y) ((y)^(((x)^(y))&amp;(-((x)&lt;(y)))))#define max(x,y) ((x)^(((x)^(y))&amp;(-((x)&lt;(y))))) 背包01背包点击显/隐 123void DP_01(int cost,int weight)&#123; for (int v=V;v&gt;=cost;v--)f[v]=max(f[v],f[v-cost]+weight);&#125; 完全背包点击显/隐 123void DP_WQ(int cost,int weight)&#123; for (int v=cost;v&lt;=V;v++)f[v]=max(f[v],f[v-c[i]]+w[i]);&#125; 多重背包点击显/隐 123456void DP_DC(int cost,int weight,int amount)&#123; if (cost*amount&gt;=V)&#123;DP_WQ(cost,weight);return ;&#125; int k=1; while (k&lt;amount/*num?*/)DP_01(k*cost,k*weight),amount-=k,k*=2; DP_01(amount*cost,amount*weight);&#125; 分组背包点击显/隐 123456void DP_FZ()&#123; for (int k=1;k&lt;=t;k++) for (int v=V;v&gt;=0;v--) for (int i=1;i&lt;=n[k];i++) if(c[k][i]&lt;=v)f[v]=max(f[v],f[v-c[k][i]]+w[k][i]);&#125; IO优化（超快的见真正的IO优化）点击显/隐 12345678910111213141516inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123; int f=1;x=0;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=nc();&#125; x*=f;&#125;inline void write(long long n)&#123; if(n==0) return; write(n/10); putchar(n%10+'0');&#125; 高精简便模板$V_{1.1}$：支持两个string的加减乘除取余阶乘比较！请注意加上string头文件！ 高精加点击显/隐 1234567891011121314#define L 100001string add(string a,string b)//只限两个非负整数相加，不支持负数&#123; string ans; int na[L]=&#123;0&#125;,nb[L]=&#123;0&#125;; int la=a.size(),lb=b.size(); for(int i=0;i&lt;la;i++) na[la-1-i]=a[i]-'0'; for(int i=0;i&lt;lb;i++) nb[lb-1-i]=b[i]-'0'; int lmax=la&gt;lb?la:lb; for(int i=0;i&lt;lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10; if(na[lmax]) lmax++; for(int i=lmax-1;i&gt;=0;i--) ans+=na[i]+'0'; return ans;&#125; 高精减点击显/隐 123456789101112131415161718#define L 100000string sub(string a,string b)//只限大的非负整数减小的非负整数&#123; string ans; int na[L]=&#123;0&#125;,nb[L]=&#123;0&#125;; int la=a.size(),lb=b.size(); for(int i=0;i&lt;la;i++) na[la-1-i]=a[i]-'0'; for(int i=0;i&lt;lb;i++) nb[lb-1-i]=b[i]-'0'; int lmax=la&gt;lb?la:lb; for(int i=0;i&lt;lmax;i++) &#123; na[i]-=nb[i]; if(na[i]&lt;0) na[i]+=10,na[i+1]--; &#125; while(!na[--lmax]&amp;&amp;lmax&gt;0) ;lmax++; for(int i=lmax-1;i&gt;=0;i--) ans+=na[i]+'0'; return ans;&#125; 高乘高点击显/隐 123456789101112131415161718#define L 100000string mul(string a,string b)//高乘高&#123; string s; int na[L],nb[L],nc[L],La=a.size(),Lb=b.size(); fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0); for(int i=La-1;i&gt;=0;i--) na[La-i]=a[i]-'0'; for(int i=Lb-1;i&gt;=0;i--) nb[Lb-i]=b[i]-'0'; for(int i=1;i&lt;=La;i++) for(int j=1;j&lt;=Lb;j++) nc[i+j-1]+=na[i]*nb[j]; for(int i=1;i&lt;=La+Lb;i++) nc[i+1]+=nc[i]/10,nc[i]%=10; if(nc[La+Lb]) s+=nc[La+Lb]+'0'; for(int i=La+Lb-1;i&gt;=1;i--) s+=nc[i]+'0'; return s;&#125; 高乘单点击显/隐 1234567891011121314#define L 100000string mulint(string a,int b)//高精度a*单精度b&#123; string ans; int La=a.size(),na[L]; fill(na,na+L,0); for(int i=La-1;i&gt;=0;i--) na[La-i-1]=a[i]-'0'; int w=0; for(int i=0;i&lt;La;i++) na[i]=na[i]*b+w,w=na[i]/10,na[i]=na[i]%10; while(w) na[La++]=w%10,w/=10; La--; while(La&gt;=0) ans+=na[La--]+'0'; return ans;&#125; 高除高点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define L 100000int sub(int *a,int *b,int La,int Lb)&#123; if(La&lt;Lb) return -1;//如果a小于b，则返回-1 if(La==Lb) &#123; for(int i=La-1;i&gt;=0;i--) if(a[i]&gt;b[i]) break; else if(a[i]&lt;b[i]) return -1;//如果a小于b，则返回-1 &#125; for(int i=0;i&lt;La;i++)//高精度减法 &#123; a[i]-=b[i]; if(a[i]&lt;0) a[i]+=10,a[i+1]--; &#125; for(int i=La-1;i&gt;=0;i--) if(a[i]) return i+1;//返回差的位数 return 0;//返回差的位数&#125;string div(string n1,string n2,int nn)//n1,n2是字符串表示的被除数，除数,nn是选择返回商还是余数&#123; string s,v;//s存商,v存余数int a[L],b[L],r[L],La=n1.size(),Lb=n2.size(),i,tp=La;//a，b是整形数组表示被除数，除数，tp保存被除数的长度 fill(a,a+L,0);fill(b,b+L,0);fill(r,r+L,0);//数组元素都置为0 for(i=La-1;i&gt;=0;i--) a[La-1-i]=n1[i]-'0'; for(i=Lb-1;i&gt;=0;i--) b[Lb-1-i]=n2[i]-'0'; if(La&lt;Lb || (La==Lb &amp;&amp; n1&lt;n2)) &#123; //cout&lt;&lt;0&lt;&lt;endl; return n1;&#125;//如果a&lt;b,则商为0，余数为被除数 int t=La-Lb;//除被数和除数的位数之差 for(int i=La-1;i&gt;=0;i--)//将除数扩大10^t倍 if(i&gt;=t) b[i]=b[i-t]; else b[i]=0; Lb=La; for(int j=0;j&lt;=t;j++) &#123; int temp; while((temp=sub(a,b+j,La,Lb-j))&gt;=0)//如果被除数比除数大继续减 &#123; La=temp; r[t-j]++; &#125; &#125; for(i=0;i&lt;L-10;i++) r[i+1]+=r[i]/10,r[i]%=10;//统一处理进位 while(!r[i]) i--;//将整形数组表示的商转化成字符串表示的 while(i&gt;=0) s+=r[i--]+'0'; //cout&lt;&lt;s&lt;&lt;endl; i=tp; while(!a[i]) i--;//将整形数组表示的余数转化成字符串表示的 while(i&gt;=0) v+=a[i--]+'0'; if(v.empty()) v="0"; //cout&lt;&lt;v&lt;&lt;endl; if(nn==1) return s; if(nn==2) return v;&#125; 高除单点击显/隐 12345678910111213141516#define L 100000string div(string a,int b)//高精度a除以单精度b&#123; string r,ans; int d=0; if(a=="0") return a;//特判 for(int i=0;i&lt;a.size();i++) &#123; r+=(d*10+a[i]-'0')/b+'0';//求出商 d=(d*10+(a[i]-'0'))%b;//求出余数 &#125; int p=0; for(int i=0;i&lt;r.size();i++) if(r[i]!='0') &#123;p=i;break;&#125; return r.substr(p);&#125; 高模单点击显/隐 1234567#define L 100000int mod(string a,int b)//高精度a除以单精度b取模&#123; int d=0; for(int i=0;i&lt;a.size();i++) d=(d*10+(a[i]-'0'))%b;//求出余数 return d;&#125; 高精阶乘点击显/隐 12345678910111213141516171819#define L 100000string fac(int n)&#123; int a[L]; string ans; if(n==0) return "1"; fill(a,a+L,0); int s=0,m=n; while(m) a[++s]=m%10,m/=10; for(int i=n-1;i&gt;=2;i--) &#123; int w=0; for(int j=1;j&lt;=s;j++) a[j]=a[j]*i+w,w=a[j]/10,a[j]=a[j]%10; while(w) a[++s]=w%10,w/=10; &#125; while(!a[s]) s--; while(s&gt;=1) ans+=a[s--]+'0'; return ans;&#125; 大整数比较模板（可比较负数）点击显/隐 12345678910111213141516171819inline bool compare(string a,string b) &#123; int i,la,lb; la=a.length(); lb=b.length(); if(a[0]=='-'&amp;&amp;b[0]!='-')return 1; if(a[0]!='-'&amp;&amp;b[0]=='-')return 0; if(a[0]=='-'&amp;&amp;b[0]=='-')&#123; string x=a,y=b; x[0]='0';y[0]='0'; return !compare(x,y); &#125; if (la&gt;lb) return 0; if (la&lt;lb) return 1; for(i=la-1; i&gt;=0; i--) &#123; if (a[i]&gt;b[i]) return 0; if (a[i]&lt;b[i]) return 1; &#125; return 0;&#125; 数据结构最强栈模板$V_{1.0}$：简单易懂！比STL易懂！支持9种操作！点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142struct Stack&#123; int s[100001]; int maxn; bool push(int x)&#123; if(maxn==100000)return 0; s[++maxn]=x; return 1; &#125; bool pop()&#123; if(maxn==0)return 0; maxn--; return 1; &#125; int get()&#123; return maxn; &#125; void clear()&#123; for(int i=0;i&lt;=100000;i++)&#123; s[i]=0; &#125; maxn=0; &#125; void visit()&#123; for(int i=1;i&lt;=maxn;i++)&#123; cout&lt;&lt;s[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; bool isin(int x)&#123; for(int i=1;i&lt;=maxn;i++)&#123; if(s[i]==x)return true; &#125; return false; &#125; void Sort()&#123; sort(s+1,s+maxn+1); &#125; void Unique()&#123; sort(s+1,s+maxn+1); maxn=unique(s+1,s+maxn+1)-s-1; &#125;&#125;; 线段树支持区间/单点的乘/加/查询，且可以通过注释一条代码实现有Mod和无Mod的转换。 点击显/隐 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define N 100005struct Segment_Tree&#123; #define ll long long ll a[N],ans[N&lt;&lt;2],taga[N&lt;&lt;2],tagm[N&lt;&lt;2],mod; mod=1ll&lt;&lt;60;//注释此行则为有Mod inline ll lson(ll p)&#123;return p&lt;&lt;1;&#125; inline ll rson(ll p)&#123;return (p&lt;&lt;1)|1;&#125; inline void push_up(ll p)&#123;ans[p]=(ans[lson(p)]+ans[rson(p)])%mod;&#125; inline void build(ll p,ll l,ll r)&#123;//建树，必须开始时调用一次！ taga[p]=0,tagm[p]=1; if(l==r)&#123;ans[p]=a[l];return ;&#125; ll mid=l+r&gt;&gt;1; build(lson(p),l,mid); build(rson(p),mid+1,r); push_up(p); &#125; inline void push_down(ll p,ll l,ll r)&#123; ll mid=l+r&gt;&gt;1; ans[lson(p)]=(ans[lson(p)]*tagm[p]+(mid-l+1)*taga[p])%mod; tagm[lson(p)]=(tagm[lson(p)]*tagm[p])%mod; taga[lson(p)]=(taga[lson(p)]*tagm[p]+taga[p])%mod; ans[rson(p)]=(ans[rson(p)]*tagm[p]+(r-mid)*taga[p])%mod; tagm[rson(p)]=(tagm[rson(p)]*tagm[p])%mod; taga[rson(p)]=(taga[rson(p)]*tagm[p]+taga[p])%mod; tagm[p]=1,taga[p]=0; &#125; inline void add(ll p,ll nl,ll nr,ll l,ll r,ll k)&#123;//区间加，调用时nl、nr为修改区间，p为1，l为1，r为n，k为加上的数。 if(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;ans[p]=(ans[p]+(r-l+1)*k)%mod;taga[p]=(taga[p]+k)%mod;return ;&#125; if(nl&gt;r||nr&lt;l)return ; push_down(p,l,r); ll mid=l+r&gt;&gt;1; add(lson(p),nl,nr,l,mid,k); add(rson(p),nl,nr,mid+1,r,k); push_up(p); &#125; inline void mul(ll p,ll nl,ll nr,ll l,ll r,ll k)&#123;//区间乘，调用时nl、nr为修改区间，p为1，l为1，r为n，k为乘上的数。 if(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;ans[p]=(ans[p]*k)%mod;tagm[p]=(tagm[p]*k)%mod;taga[p]=(taga[p]*k);return;&#125; if(nl&gt;r||nr&lt;l)return; push_down(p,l,r); ll mid=l+r&gt;&gt;1; mul(lson(p),nl,nr,l,mid,k); mul(rson(p),nl,nr,mid+1,r,k); push_up(p); &#125; inline ll ask(ll p,ll nl,ll nr,ll l,ll r)&#123;//区间查询，调用时nl、nr为修改区间，p为1，l为1，r为n。 if(nl&lt;=l&amp;&amp;nr&gt;=r)return ans[p]; if(nl&gt;r||nr&lt;l)return 0; push_down(p,l,r); ll mid=l+r&gt;&gt;1,res=0; res=(res+ask(lson(p),nl,nr,l,mid))%mod; res=(res+ask(rson(p),nl,nr,mid+1,r))%mod; return res; &#125;&#125; 注：关于高精和栈的模板来自罗陈（天卜的心事）c++小组]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3377 【【模板】左偏树（可并堆）】]]></title>
    <url>%2F2019%2F03%2F03%2F%E9%A2%98%E8%A7%A3-P3377-%E3%80%90%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%88%E5%8F%AF%E5%B9%B6%E5%A0%86%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[折腾了几天终于把这个题A了。。。 看到手写左偏树/配对堆已经有很多题解了，而pbds却没有人介绍，我来介绍一发 首先，pbds是什么？ pbds是一个比STL还STL的库，里面封装了各种可并堆、红黑树等等数据结构，大大地方便了oier。 最重要的是，NOIP支持pbds了！既然如此那我们当然选择封装而不是手写 解下来的内容大佬请略过 具体的代码里说吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;//引用pbds的库的堆#pragma GCC optimize(3)using namespace std;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123; int f=1;x=0;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=nc();&#125; x*=f;&#125;inline void write(long long n)&#123; if(n==0) return; write(n/10); putchar(n%10+'0');&#125;struct $&#123; int s,id; inline bool operator &lt; (const $ &amp;p)const&#123;if (s!=p.s)return s&gt;p.s;else return id&gt;p.id;&#125;//注意！由于使用了pbds，只能重载运算符。而且pbds中的堆很毒瘤，它把&lt;重载成&gt;，然后排&gt;，所以重载的时候要注意反着重载&#125;;//结构体，存每个数的数值和idinline $ g(int a,int b)&#123;$ p;p.s=a,p.id=b;return p;&#125;//将2个int转成一个$__gnu_pbds::priority_queue&lt;$&gt; q[100005];//定义一个pbds的堆//使用__gnu_pbds::来引用pbds内的内容int n,m,f[100005],x;bool s[100005];//如果s[i]==1则i被删除int find(int n)&#123;return f[n]==n?n:f[n]=find(f[n]);&#125;//维护并查集，这里实际上可以路径压缩int main()&#123; read(n),read(m); for (int i=1;i&lt;=n;i++)read(x),q[i].push(g(x,i)),f[i]=i;//读入的同时对每个i建一个堆，同时初始化并查集 while (m--)&#123; read(x); if (x==1)&#123; int a,b; read(a),read(b); int fa=find(a),fb=find(b); if (fa==fb||s[a]||s[b])continue;//坑点1：注意不要把s[a]||s[b]写成了s[fa]||s[fb] if (q[fa].size()&gt;q[fb].size())f[fb]=fa,q[fa].join(q[fb]);//按堆的大小合并 else f[fa]=fb,q[fb].join(q[fa]); &#125;else&#123; int a; read(a); if (s[a])&#123;puts("-1");continue;&#125; int fa=find(a); write((q[fa].top()).s),puts(""),s[(q[fa].top()).id]=1,q[fa].pop();//同普通堆 &#125; &#125;&#125; 看了一下，我的代码应该算短的。而且开了O3之后，封装的也不慢，所以向大家强烈推荐pbds！]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1638 【逛画展】]]></title>
    <url>%2F2019%2F02%2F24%2F%E9%A2%98%E8%A7%A3-P1638-%E3%80%90%E9%80%9B%E7%94%BB%E5%B1%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[看了一下前面的题解都麻烦了，所以来一发简单的题解 因为是要求看的画是连续的，所以可以考虑尺取法（双指针法） 既然要求要看到M位画家的画，我们可以考虑维护一个区间[l,r]，保证这个区间是含有M位画家且以l开头最小的区间，则如果想更新答案获得更小区间，只能右移l，而不能左移r。 为什么呢？ 考虑反证法。 假设有一个区间[l,r-k]比[l,r]更优，则这段区间会在r=r-k的时候就被更新，所以左移r无用。 所以r就满足单调性（只增不减），可以用尺取法做。 代码： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1000005;int n,m,a[MAXN],ans,b[MAXN],cnt,ansl,ansr;inline void I(int x)&#123;if(b[x]==0)cnt++;b[x]++;&#125;//加入第x位画家的画inline void D(int x)&#123;if(b[x]==1)cnt--;b[x]--;&#125;//删除第x位画家的画int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf ("%d",&amp;a[i]); ans=n; for(int r=1,l=1;r&lt;=n;r++)&#123; I(a[r]);//首先插入a[r]的画 while(true)&#123; D(a[l]);//先删a[l]的画 if(cnt==m)l++;//如果删了没事，加l else&#123;I(a[l]);break;&#125;//删了有事，还留着 &#125; if(cnt==m&amp;&amp;r-l+1&lt;ans)ans=r-l+1,ansl=l,ansr=r; &#125; if (ansl!=0)printf ("%d %d",ansl,ansr); else printf ("1 %d",n);//输出+特判：选择任意一个≤n的区间不满足要求，则只好选择区间[1,n] return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF660C 【Hard Process】]]></title>
    <url>%2F2019%2F02%2F10%2F%E9%A2%98%E8%A7%A3-CF660C-%E3%80%90Hard-Process%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到C++的都是二分的尺取法表示不服 这题朴素想法：枚举l，r，暴力求[l,r]中0的个数是否小于k，复杂度$O(n^{3})$ 我们想想有没有什么优化的办法 很明显，对于一个含0的区间，我们让区间中的0都填满是最优的 于是维护一段区间，保证区间中的0的个数≤k就可以 于是就可以对于0的个数≤k时右移右端点，增添新的位置，扩大区间； 当[l,r]中0的个数＞k时我们没有必要再回到l从头开始，可以只右移l，到[l,r]中0的个数≤k时为止（其实最后肯定=k，自己想想为什么！） 于是复杂度降到了线性的$O(n)$，或成此题最优解？ 并不长的代码： 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int a[300005],k,n,ans,cnt,ml,mr;int main()&#123; scanf ("%d%d",&amp;n,&amp;k); for (int i=1;i&lt;=n;i++)scanf ("%d",&amp;a[i]); for (int l=1,r=1;r&lt;=n;r++)&#123;//持续右移右端点 cnt+=!a[r]; if (cnt&gt;k)&#123; cnt-=!a[l]; l++; &#125;//长了就右移左端点 if (r-l+1&gt;ans)ans=r-l+1,ml=l,mr=r; &#125; for (;ml&lt;=mr;ml++)a[ml]=1; printf ("%d\n",ans); for (int i=1;i&lt;=n;i++)printf ("%d ",a[i]);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 UVA11366 【Circle of Debt】]]></title>
    <url>%2F2019%2F02%2F10%2F%E9%A2%98%E8%A7%A3-UVA11366-%E3%80%90Circle-of-Debt%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意： A欠B $ab$ 元，B欠C $bc$ 元，C欠A $ca$ 元。现在告诉你每个人的100元，50元，20元，10元，5元，1元的硬币各有多少个，问你最少需要交换多少张硬币才能还清他们之间的债务。（当$ab$=$bc$=$ca$时就可以认为债务已经还清）无法还清输出$impossible$每个人最多有30张硬币，他们的总钱数不多与1000元。——FlierKing的课件 这个麻烦管理员顺手搬到题面上。 这题目一看就是搜索 但纯爆搜是肯定要T的 首先是一个基本性的优化： 对于每个币种，只可能有两种情况： 两个人给一个人钱 一个人给两个人钱 那么搜索的复杂度就减少了 然后是两个非常常见的优化： 最优性剪枝：如果当前的答案已经不如已有的答案了，剪枝； 可行性剪枝：我们考虑先搜索面值小的硬币，然后搜索大面值的硬币时，每两个人直接的欠的金额差必须可以被此时剩下面值的硬币的最大公因数整除，不然这两个人之间就永远纠缠不清。 加上这些优化代码AC就没什么问题了。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define inf 2147483647using namespace std;int t,d[3],ans,cnt,u[3][6],td[3],a[6][4];const int v[]=&#123;100,50,20,10,5,1&#125;;//币种数组bool check(int x,int y)&#123;//暴力判可行 switch(y)&#123; case 5:return true; case 4:return x%5==0; case 2:return x%10==0; case 1:return x%50==0; case 0:return x%100==0; &#125;&#125;void dfs(int x)&#123; if(x&lt;0)&#123;if(td[0]==td[1]&amp;&amp;td[1]==td[2])ans=min(ans,cnt);return;&#125;//债务还清了，更新答案 if(cnt&gt;=ans)return;//最优性剪枝 if(!check(td[0]-td[1],x)||!check(td[1]-td[2],x))return;//可行性剪枝 for(int i=0;i&lt;3;i++)&#123; int nex=(i+1)%3,pre=(i+2)%3; for(int j=0;j&lt;=u[i][x];j++) for(int k=0;k&lt;=u[i][x]-j;k++)&#123; td[i]-=j*v[x],td[pre]+=k*v[x],cnt+=j+k; dfs(x-1); cnt-=j+k,td[i]+=j*v[x],td[pre]-=k*v[x]; &#125; for(int j=0;j&lt;=u[nex][x];j++) for(int k=0;k&lt;=u[pre][x];k++)&#123; td[i]+=j*v[x],td[pre]-=k*v[x],cnt+=j+k; dfs(x-1); cnt-=j+k,td[i]-=j*v[x],td[pre]+=k*v[x]; &#125; &#125;&#125;int main()&#123; scanf ("%d",&amp;t); while(t--)&#123; ans=inf; for(int i=0;i&lt;3;i++)scanf ("%d",&amp;td[i]),d[i]=td[i]; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;6;j++)scanf ("%d",&amp;u[i][j]); dfs(5); if(ans==inf)puts("impossible"); else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年离我们而去的Oier们]]></title>
    <url>%2F2019%2F01%2F22%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%A6%BB%E6%88%91%E4%BB%AC%E8%80%8C%E5%8E%BB%E7%9A%84Oier%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[我自己也算是半个退役的人了，所以看到别人离去，觉得我自己的那一天也不远了 所以就开始搞这个。 $ \color{blue} \text{strangers} $退役于2018.11.08。 这位巨佬特强 看题目统计就知道 $ \color{white} \colorbox{grey}{尚无评定} $ 7 $ \color{white} \colorbox{red}{入门难度} $ 58 $ \color{white} \colorbox{orange}{普及-} $ 98 $ \color{white} \colorbox{yellow}{普及/提高-} $ 123 $ \color{white} \colorbox{green}{普及+/提高} $ 85 $ \color{white} \colorbox{blue}{提高+/省选-} $ 294 $ \color{white} \colorbox{purple}{省选/NOI-} $ 331 $ \color{white} \colorbox{black}{NOI/NOI+/CTSC} $ 32 称“切黄题”为颓废、高二入坑高三退坑时就已经能AK IOI的人。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建食用指北]]></title>
    <url>%2F2019%2F01%2F18%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[最近打算自己搭个blog，于是就看了很多有关的文章 比较有用的：https://ouuan.github.io/hexo博客搭建指北/ 嗯嗯有些不够详细的我来说一说 updated on 2019.8.3 最近在修图片的锅，大部分图片已撤下，请过段时间再来看QAQ 域名域名的申请土豪请略过，我这里谈的是免费的 首先打开freenom 网站打开可能会有点慢，先看看别的网页，耐心等等 重要！不要试图将语言切换为中文，至少在我的浏览器上中文会挂，网页都失去了功能 搜索你想要的域名 别问我为什么是这个域名 选择你想要的 结算 进入结算页面 比方说你想保留kkksc03.ml 那么kkksc03.tk就设置成跳转到kkksc03.ml 先点1，把3 Months @FREE改成12 Months @FREE 不然你的域名有效期只有3个月 然后点你要保留的域名中的2(Use DNS) 点3(Use your own DNS) 选择你的DNS服务商： 建议： dnspod Cloudflare 连接域名和DNS dnspod在5处填f1g1ns1.dnspod.net 在6处填f1g1ns2.dnspod.net 然后打开dnspod 登录 点域名解析 点添加域名 输入你的主域名（即域名的后半部分） 例：www.kkksc03.ml-&gt;kkksc03.ml 点确定 等它一下 导好之后 确认就可以 添加记录 添加一个www记录，一个@记录（这样保险） 然后记录值随便输一个***.***.***.***类型的就可以 保存 Cloudflare5处填mimi.ns.cloudflare.com 6处填oswald.ns.cloudflare.com Cloudflare的注册等会再说 回到freenom 点continue 进入账单 在左下角”Enter Your Email Address”的位置输入你的邮箱（部分邮箱用不了），点下面的蓝色按钮注册 我已经有账号了所以我点右上角的”Sign in”直接登录了 然后域名就申请好了 Hexo blog注：这里只介绍next主题。 根目录下的_config.yml好像只有一点东西可以设啊 作者应该在第10行的位置 1author: yourname 把yourname改成你的名字即可。 语言应该在第11行的位置 1language: zh-CN 这样页面语言就是中文了。 主题目录下的_config.yml这部分基本上就是抄的了，我只是解释一下 选择4种主题中的一种12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 把想要的那一种前面的#去掉，不想要的加上即可。 改变网站图标12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 把你想要的图标放到\themes\next\source\images里，然后修改上面的文件名即可。 注：大小要符合 页脚设置1234567891011121314151617181920212223242526272829303132333435footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.0/icons # `heart` is recommended with animation in red (#ff0000). name: battery-full # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: "#808080" # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: icon： © 2019 与用户名之间的图标。（图中 1） 图标名称为 Font Awesome 上的图标名称。 powered.enable：为 true 则会显示 “由 Hexo 强力驱动”。（图中 2 ） powered.version：为 true 则会显示 Hexo 的版本。（图中 3 ） powered.enable：为 true 则会显示“主题 – NexT.XX”。（图中 4） powered.version：为 true 则会显示主题的版本。（图中 5） 搬运Markdown好累啊 “关于”&amp;“标签”123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要的项目取消注释即可在侧边栏显示。 如果需要使用“关于”页面，输入命令 hexo new page &quot;about&quot;。 然后在 \source\about\index.md 中就可以编辑“关于”页面了。 可以修改 \source\about\index.md 中的 title 项来显示“关于”而非“about”。 如果需要使用“标签”功能，需要在博文中添加选项 tags ： 如果有多个标签，每行一个，以 - 开头： 1234tags:- 标签1- 标签2- 标签3 如果需要使用“标签”页面，输入命令 hexo new page &quot;tags&quot;。 然后向 source\tags\index.md 中添加一行： 1type: "tags" 站内搜索输入命令 npm install hexo-generator-searchdb --save 安装所需的库。 在根目录下的 _config.yml 的结尾加入： 12345search: path: search.xml field: post format: html limit: 10000 然后在 \themes\next\_config.yml 中，打开 local_search： 12local_search: enable: true 社♂交网站123456789101112131415# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/yltx || github 洛谷: https://www.luogu.org/space/show?uid=39863 || code Codeforces: https://www.codeforces.com/profile/yltx || code b站: https://space.bilibili.com/11067182 || tvsocial_icons: enable: true icons_only: false transition: false 在 social 下每行一个，格式为：名称: 地址 || 图标。 其中，“图标”为 Font Awesome 图标名称，但有些图标是不可用的，而且图标也不全，使用的时候要尝试一下图标是否可用。 12social_icons: enable: false 这样设置可以只显示名称不显示图标。 友情链接（或其它链接）1234567# Blog rollslinks_icon: globelinks_title: 友链# links_layout: blocklinks_layout: inlinelinks: 引领天下: https://www.yltx.cf links_icon：显示在标题前的图标。 links_title：标题。 links_layout：block 一行一个，inline 一行多个。 links：要显示的链接以及名称。 头像123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url：头像地址，留空则不显示头像。 rounded：圆/方头像。 opacity：不透明度。 rotated：随光标旋转。 回到顶部按钮/阅读百分比12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 博客首页不显示全文在博文里可以用 &lt;!-- more --&gt; 来标识在首页显示到哪为止。 可以在 \themes\next\_config.yml 里设置到一定字数自动不显示全文： 123456789# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Read more button# If true, the read more button would be displayed in excerpt sectionread_more_btn: true length：不显示全文的字数上限。 read_more_btn： 代码块复制按钮123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true enable：启用复制按钮。 show_result： $\LaTeX$1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has 'mathjax: true' in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: false engine: mathjax #engine: katex enable：启用$\LaTeX$。 per_page：为 true 则只有博文中有 mathjax: true 才会启用$\LaTeX$，否则每篇博客都会启用$\LaTeX$。 engine：推荐使用 mathjax 。 hexo 博客的 mathjax 和 Markdown 有一些冲突，将在后文专门讲解如何解决冲突。 评论功能由于 gitment 的服务器有一些问题，推荐使用 gitalk： 1234567gitalk: enable: true github_id: yourname repo: yourname.github.io client_id: client_secret: admin_user: yourname 这里需要在 GitHub 新建一个 OAuth App，“Homepage URL”和“Authorization callback URL”填你的域名（如果没有申请域名的话就填 yourname.github.io）： 需要注意的是，地址要严格和博客访问地址一样，http 和 https不能混，有无 www 也不能混。 然后将 Client ID 和 Client Secret 填入 \themes\next\_config.yml 中。 访客记录12busuanzi_count: enable: true 书签书签的功能是关闭页面/手动点击书签按钮时，保存这篇博客看到的位置，下次点进这篇博客时继续从这个位置开始。 安装插件： 1git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark 更改 \themes\next\_config.yml： 123456789# Bookmark Support# Dependencies: https://github.com/theme-next/theme-next-bookmarkbookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: manual convas背景安装插件：进入/next文件夹，输入 1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 然后修改主题配置： 123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines RGB选项可以自己配置线条颜色。 其他配置博客背景打开 \themes\next\source\css\_custom\custom.styl，输入： 1234body &#123; background-image:url(/images/background.jpg); background-size: cover;&#125; 把背景图片重命名为 background.jpg，放入 \themes\source\images（当然也可以更改background-image:url()）。 background-size: cover; 表示宽度缩放至页面大小。 123456body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover;&#125; 如果修改成这样的话背景图片就不会滚动。 如果不想让博客内容挡住背景，可以设置博客内容的透明度，在 \themes\next\source\css\_custom\custom.styl 中加入下面的代码即可： 123.main-inner &#123; opacity: 0.8;&#125; README.md如果想在 https://github.com/yourname/yourname.github.io 让别人看到你的博客的简介，就需要写一个 README.md 放在根目录下的 source 文件夹内。 然而，只是这样的话， README.md 会被渲染成 html，所以需要更改根目录下 _config.yml 的设置： 1skip_render: README.md 自定义404页面首先写一个 \source\404.html 。 至于怎么写html……关于这个问题，我想到了一种美妙的解法，可惜这里地方太小写不下作者最近打算抽空写个专门介绍404.html的博文呢…… 事实上可以新建一篇博客，用 Markdown 写一个 404 页面，然后 hexo g 在 \public 里找到博客的页面，把相关部分直接复制过来。 可以参考一下我的： 123456789101112&lt;body background="https://raw.githubusercontent.com/yltx/yltx.github.io/master/images/background.jpg" font-family: "楷体"&gt; &lt;style&gt;body &#123;font-family: 楷体;&#125;&lt;/style&gt; &lt;div style="text-align: center;"&gt; &lt;link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css"&gt; &lt;script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;p style="font-size: 50px;color: gold"&gt;&lt;strong&gt;您可能访问了错误的网址&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;404,that page cannot be found.&lt;/strong&gt;&lt;br/&gt;&lt;img src="https://i.loli.net/2019/03/03/5c7b8d8caeefe.gif"&gt;&lt;/p&gt; &lt;p style="font-size: 30px;color:silver"&gt;&lt;a href="https://www.yltx.cf"&gt;&lt;button type="button" class="btn btn-info"&gt;回到博客主页&lt;/button&gt;&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href="javascript:history.go(-1);"&gt;&lt;button type="button" class="btn btn-info"&gt;返回上一页&lt;/button&gt;&lt;/a&gt;&lt;/p&gt; &lt;!-- &lt;p &lt;a href="https://www.yltx.cf"&gt;&lt;strong&gt;回到博客主页&lt;/strong&gt;&lt;/a&gt;&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&lt;a href="javascript:history.go(-1);"&gt;&lt;strong&gt;返回上一页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; --&gt; &lt;!-- &lt;p style="text-align: center;"&gt;&lt;/p&gt; --&gt; &lt;/div&gt;&lt;/body&gt; 发布效果：https://yltx.cf/404 然后，如果直接这样发布，html 会被渲染，就跟一个自定义页面（hexo new page）一样了。 所以要修改根目录下的 _config.yml，在 skip_render: 后添加 404.html，如果有多项用 - 隔开： 123skip_render: - README.md - 404.html 发布完成后，访问一个错误的网址，比如 你的域名/qaq 就可以查看效果了。 折叠效果原文 效果见下面附录部分 博文自定义排序打开 \node_modules\hexo-generator-index\lib\generator.js 。 用以下内容覆盖原内容↓ 12345678910111213141516171819202122232425262728293031var pagination = require('hexo-pagination');module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 之后在博文设置中加入 top: x 即可，会以 top 为第一关键字，时间为第二关键字排序。若 top 为空则视作 -INF 。 原文 连接github配置github仓库首先你要有一个github账号…… 然后登录 新建一个repo： 输入名字，保存： 注意：yourname要换成你的githubID。 比方说我的就是yltx.github.io 然后点2就可以了。 上传在本地输入： 1ssh-keygen 让你输东西就空着，按回车就行（应该要三次吧） 输入命令： 1cat ~/.ssh/id_rsa.pub 复制窗口中出现的一堆乱码一样的东西 然后回到github，点头像打开Settings 点击左侧的SSH and GPG keys 我的已经有一个了不用管 点New SSH Keys，新建一个，标题随便，把刚才复制的一堆东西粘贴进去，然后点”Add SSH key”就行了。 然后在本地输入命令 1ssh -T git@github.com 若出现Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access就表示SSH配置成功了 输入命令 1npm install hexo-deployer-git --save 就可以安装deployer。 打开根目录（在本地创建的那个文件夹）下的_config.yml，在最后输入： 1234deploy: type: git repository: https://github.com/yourname.github.io.git branch: master 当然yourname要改成你的Github ID了。 输入命令： 123hexo clhexo ghexo d 这一步可能要输入密码（出现一个弹框） 以后可以用简化的命令： 12hexo clhexo g -d 等几分钟，打开yourname.github.io应该就可以看到你的博客了。 那么恭喜你，你上传好了。 连接域名和github先在hexo根目录的source子目录下新建文件CNAME（重要！没有.txt之类的后缀名！） 然后打开，输入你的域名（注意，如果使用gitalk，在此处输入的域名必须与App中的一样） 例： CNAME： 1yltx.cf App： 1https://yltx.cf 千万不能随便加www！要加要一起加！ dnspod在本地打开cmd（命令提示符），输入命令： 1ping yourname.github.io yourname要换成你自己的githubID。 会出来一个IP地址： 我红笔圈出来的部分 然后打开dnspod中你之前添加的域名 把这个IP填到之前dnspod我们瞎填111.111.111.111的地方，保存 Cloudflare打开Cloudflare官网 有的登录，没的注册 登录好了之后： 点右上角的Add Site，输入你的域名 添加好之后 接下来肯定是点Next啦 咳咳咳选哪个套餐就看你有多少钱啦 我选的是FREE 点Confirm Plan 再点一次Confirm 不要问我为什么换了域名，因为Cloudflare要求要存在的域名，而我并没有真的申请kkksc03.ml 然后点continue应该就可以了 在本地输入命令： 1hexo d 过几分钟域名应该就可以用了。 开启https如果不开启的话，访问 https://你的域名 就会显示警告，访问 http://你的域名 就会显示不安全。 当然如果因为某种原因访问 https://你的域名 已经不会显示警告而且浏览器左上角有绿锁了，就不需要再进行额外的设置了。 其实很简单，浏览器打开https://github.com/yourname/yourname.github.io/settings，找到这里： （我已经开过了） 勾选Enforce HTTPS即可。 停用域名单纯停用只需删去 CNAME 文件即可，然后记得更改相关设置（在各种地方引用的博客链接、OAuth App 地址……）。 Q&amp;AQ1Q：“Enforce HTTPS”前面是灰色的，无法打勾 A： 删掉“Save”前面的域名，点击“Save”。 重新输入域名，点击“Save”。 重新发布博客（hexo d）。 等待几分钟~几小时，再访问你的博客应该就OK了。 Q2Q：gitalk用不了 A：检查App和CNAME域名是否相同（上文说过） 特殊的：如果开启了https则URL一定要填https。 Q3Q：停用域名不成功，即：在电脑上访问博客还是自动跳转到原有域名 A： 按F12 点Network 勾选Disable Cache 按Ctrl+F5强制刷新 取消勾选 方法来源 Q4Q：代码块出锅，没有高亮，还没办法复制 A：检查根目录下的_config.yml，将highlight一段改成下面即可： 点击展开/收起 12345highlight: enable: true line_number: true auto_detect: true tab_replace: 附录常用命令1hexo cl 删除编译文件夹public，方便重新编译 1hexo g 编译。 1hexo d 上传。 1hexo g -d 编译后上传。 1hexo new page "xxx" 新建一个以“xxx”为名的页面，md文件直接存放在\source文件夹下。 1hexo n "xxx" 新建一篇以“xxx”为名的博文，md文件存放在\source\_posts文件夹下。 原始的next主题的_config.yml方便您备份。 点击展开/收起 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063# ---------------------------------------------------------------# Theme Core Configuration Settings# ---------------------------------------------------------------# If false, merge configs from `_data/next.yml` into default configuration (rewrite).# If true, will fully override default configuration by options from `_data/next.yml` (override). Only for NexT settings.# And if true, all config from default NexT `_config.yml` must be copied into `next.yml`. Use if you know what you are doing.# Useful if you want to comment some options from NexT `_config.yml` by `next.yml` without editing default config.override: false# Allow to cache content generation. Introduced in NexT v6.0.0.cache: enable: true# Redefine custom file paths. Introduced in NexT v6.0.2.# If commented, will be used default custom file paths.# For example, you want to put your custom styles file# outside theme directory in root `source/_data`, set# `styles: source/_data/styles.styl`#custom_file_path: # Default paths: layout/_custom/* #head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig # Default path: source/css/_variables/custom.styl #variables: source/_data/variables.styl # Default path: source/css/_mixins/custom.styl #mixins: source/_data/mixins.styl # Default path: source/css/_custom/custom.styl #styles: source/_data/styles.styl# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# To get or check favicons visit: https://realfavicongenerator.net# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine them on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss:footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: "#808080" # If not defined, `author` from Hexo main config will be used. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: true # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a href="https://pages.coding.me" class="theme-link" rel="noopener" target="_blank"&gt;Coding Pages&lt;/a&gt;# Creative Commons 4.0 International License.# https://creativecommons.org/share-your-work/licensing-types-examples# Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: license: by-nc-sa sidebar: false post: false# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml (e.g. url: http://yourdomain.com)canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# Automatically add external URL with BASE64 encrypt &amp; decrypt.exturl: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.# External url should start with http:// or https://menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons / item badges.menu_settings: icons: true badges: false# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Posts / Categories / Tags in sidebar.site_state: true# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.#social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.#github_banner: https://github.com/yourname || Follow me on GitHub# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links: #Title: http://example.com# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: #/images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: false # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false # Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` var. max_depth: 6sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left #position: right # Manual define the sidebar width. # If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 #width: 300 # Sidebar Display, available values (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar. b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.save_scroll: false# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150# Read more button# If true, the read more button would be displayed in excerpt section.read_more_btn: true# Post meta display settingspost_meta: item_text: true created_at: true updated_at: enabled: true # If true, show updated date label only if `updated date` different from `created date` (post edited in another day than was created). # And if post will edited in same day as created, edited time will show in popup title under created time label. # If false show anyway, but if post edited in same day, show only edited time. another_day: true categories: true# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: false # Show text copy result show_result: false# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode e.g. /uploads/wechat-qcode.jpg #description: e.g. subscribe to my blog by scanning my public wechat account# Reward# If true, reward would be displayed in every article by default.# And you can show or hide one article specially through add page variable `reward: true/false`.reward: enable: false #comment: Donate comment here #wechatpay: /images/wechatpay.jpg #alipay: /images/alipay.jpg #bitcoin: /images/bitcoin.jpg# Related popular posts# Dependencies: https://github.com/tea3/hexo-related-popular-postsrelated_posts: enable: false title: # custom header, leave empty to use the default one display_in_home: false params: maxCount: 5 #PPMixingRate: 0.0 #isDate: false #isImage: false #isExcerpt: false# Post edit# Dependencies: https://github.com/hexojs/hexo-deployer-gitpost_edit: enable: false url: https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name # Link for view source. #url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name # Link for fork &amp; edit.# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Disable Baidu tranformation on mobile devices.disable_baidu_tranformation: false# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($brand-bg / $headband-bg =&gt; $black-deep).android_chrome_color: "#222"# Custom Logo# Do not support Scheme Mist currently.# Options:# enabled: If true, will enable custom logo# image: Images's url, replace it with specific imagecustom_logo: enabled: false image:# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# Enable "cheers" for archive page.cheers_enabled: true# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduced in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used for all elements in &lt;body&gt;. global: external: true family: Lato size: # Font settings for Headlines (H1, H2, H3, H4, H5, H6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# Math Equations Render Supportmath: enable: false # Default(true) will load mathjax/katex script on demand # That is it only render those page who has `mathjax: true` in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true engine: mathjax #engine: katex # hexo-rendering-pandoc (or hexo-renderer-kramed) needed to full MathJax support. mathjax: # Use 2.7.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML # For direct link to MathJax.js with CloudFlare CDN (cdnjs.cloudflare.com) #cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML # See: https://mhchem.github.io/MathJax-mhchem/ #mhchem: //cdn.jsdelivr.net/npm/mathjax-mhchem@3 #mhchem: //cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0 # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) needed to full Katex support. katex: # Use 0.7.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/katex@0.7.1/dist/katex.min.css # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China #cdn: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css copy_tex: # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex enable: false copy_tex_js: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js copy_tex_css: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css# PDF Support# Dependencies: https://github.com/theme-next/theme-next-pdfpdf: enable: false # Default(true) will load PDFObject/PDF.js script on demand # That is it only render those page who has `pdf: true` in Front Matter. # If you set it to false, it will load PDFObject/PDF.js srcipt EVERY PAGE. per_page: true height: 500px pdfobject: # Use 2.1.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China #cdn: //cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js# Han Support# Dependencies: https://github.com/theme-next/theme-next-hanhan: false# Pangu Support# Dependencies: https://github.com/theme-next/theme-next-pangu# For more information: https://github.com/vinta/pangu.jspangu: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Growingio Analytics ID# Copyright 2015-2018 GrowingIO, Inc. More info available at https://www.growingio.com#growingio_analytics: #your projectId# Disqusdisqus: enable: false shortname: count: true lazyload: false# Changyanchangyan: enable: false appid: appkey:# Valine# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: false # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Gitment# Introduction: https://github.com/imsun/gitmentgitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github Username github_repo: # MUST HAVE, The name of the repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Gitalk# Demo: https://gitalk.github.io# Reference: https://asdfv1929.github.io/2018/01/20/gitalk/, https://liujunzhou.cn/2018/8/10/gitalk-error/#moregitalk: enable: false github_id: # Github repo owner repo: # Repository name to store issues. client_id: # Github Application Client ID client_secret: # Github Application Client Secret admin_user: # GitHub repo owner and collaborators, only these guys can initialize github issues distraction_free_mode: true # Facebook-like distraction free mode# Baidu Share# Available values:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# AddThis Share, See: https://www.addthis.com# Go to https://www.addthis.com/dashboard to customize your tools#add_this_id:# NeedMoreShare2# Dependencies: https://github.com/theme-next/theme-next-needmoreshare2# See: https://github.com/revir/need-more-share2, https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks:# Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,# Slashdot,Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru#yandex_site_verification:# Baidu Webmaster tools verification setting# See: https://ziyuan.baidu.com/site#baidu_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See: https://azure.microsoft.com/en-us/services/application-insights#application_insights:# Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: true betterPerformance: false# Another tool to show number of visitors to each article.# Visit https://console.firebase.google.com/u/0/ to get apiKey and projectId.# Visit https://firebase.google.com/docs/firestore/ to get more information about firestore.firestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: false total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye# Tencent analytics ID#tencent_analytics:# Tencent MTA ID#tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO.baidu_push: false# Google Calendar# Share your recent schedule to others via calendar page.# API Documentation: https://developers.google.com/google-apps/calendar/v3/reference/events/list# Enabled APIs and services# api_key: https://console.developers.google.com# Create &amp; manage a public Google calendar: https://support.google.com/calendar/answer/37083calendar: enable: false calendar_id: &lt;required&gt; # Your Google account E-Mail api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 # Time Range offsetMin: 4 # Time Range showDeleted: false singleEvents: true maxResults: 250# Algolia Search# See: https://github.com/theme-next/hexo-theme-next/blob/master/docs/ALGOLIA-SEARCH.md# Dependencies: https://github.com/theme-next/theme-next-algolia-instant-searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: false # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false# Bookmark Support# Dependencies: https://github.com/theme-next/theme-next-bookmarkbookmark: enable: false # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: auto# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# See: https://theme-next.org/docs/tag-plugins/# Note tag (bs-callout)note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label taglabel: true# Tabs tagtabs: enable: true transition: tabs: false labels: true border_radius: 0# Reading progress bar# Dependencies: https://github.com/theme-next/theme-next-reading-progressreading_progress: enable: false color: "#37c6c0" height: 2px#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancybox. There is support for old version 2 and new version 3.# Choose only any one variant, do not need to install both.# To install 2.x: https://github.com/theme-next/theme-next-fancybox# To install 3.x: https://github.com/theme-next/theme-next-fancybox3fancybox: false# Added switch option for separated repo in 6.0.0.# Dependencies: https://github.com/theme-next/theme-next-fastclickfastclick: false# Added switch option for separated repo in 6.0.0.# Dependencies: https://github.com/theme-next/theme-next-jquery-lazyloadlazyload: false# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: false# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: false onmobile: true # display on mobile or not color: '0,0,255' # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Canvas-ribbon# Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 # Example: # jquery: //cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js # jquery: //cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js jquery: # Internal version: 2.1.5 # See: https://fancyapps.com/fancybox # Example: # fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js # fancybox: //cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.js # fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css # fancybox_css: //cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.css fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick # Example: # fastclick: //cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js # fastclick: //cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload # Example: # lazyload: //cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js # lazyload: //cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org # Example: # velocity: //cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js # velocity: //cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js # velocity_ui: //cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js # velocity_ui: //cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js velocity: velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js # Example: # ua_parser: //cdn.jsdelivr.net/npm/ua-parser-js@0/src/ua-parser.min.js # ua_parser: //cdnjs.cloudflare.com/ajax/libs/UAParser.js/0.7.9/ua-parser.min.js ua_parser: # Internal version: 4.6.2 # See: https://fontawesome.com # Example: # fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css # fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css fontawesome: # Internal version: 2.4.1 # See: https://www.algolia.com # Example: # algolia_instant_js: //cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.js # algolia_instant_css: //cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Example: # pace: //cdn.jsdelivr.net/npm/pace-js@1/pace.min.js # pace: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js # pace_css: //cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css # pace_css: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css pace: pace_css: # Internal version: 1.0.0 # See: https://github.com/theme-next/theme-next-canvas-nest # Example: # canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js # canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js canvas_nest: canvas_nest_nomobile: # Internal version: 1.0.0 # See: https://github.com/theme-next/theme-next-three # Example: # three: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js # three_waves: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js # canvas_lines: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js # canvas_sphere: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js three: three_waves: canvas_lines: canvas_sphere: # Internal version: 1.0.0 # See: https://github.com/zproo/canvas-ribbon # Example: # canvas_ribbon: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js canvas_ribbon: # Internal version: 3.3.0 # See: https://github.com/ethantw/Han # Example: # han: //cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css # han: //cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css han: # Internal version: 3.3.0 # See: https://github.com/vinta/pangu.js # Example: # pangu: //cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js # pangu: //cdnjs.cloudflare.com/ajax/libs/pangu/3.3.0/pangu.min.js pangu: # Internal version: 1.0.0 # See: https://github.com/revir/need-more-share2 # Example: # needmoreshare2_js: //cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js # needmoreshare2_css: //cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css needmoreshare2_js: needmoreshare2_css: # Internal version: 1.0.0 # See: https://github.com/theme-next/theme-next-bookmark # Example: # bookmark: //cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js bookmark: # Internal version: 1.1 # See: https://github.com/theme-next/theme-next-reading-progress # Example: # reading_progress: //cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js reading_progress: # leancloud-storage # See: https://www.npmjs.com/package/leancloud-storage # Example: # leancloud: //cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js leancloud: # valine # See: https://github.com/xCss/Valine # Example: # valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js # valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js valine: # gitalk # See: https://github.com/gitalk/gitalk # Example: # gitalk_js: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js # gitalk_css: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css gitalk_js: gitalk_css: # js-md5 # See: https://github.com/emn178/js-md5 # Example: # md5: //cdn.jsdelivr.net/npm/js-md5@0/src/md5.min.js md5:# Assetscss: cssjs: jsimages: images]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1482 【Cantor表（升级版）】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1482-%E3%80%90Cantor%E8%A1%A8%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[我想问一下楼下是肿么想的。 写了读入优化不用。。。。。 还有求最大公约数何必暴力？？ 额额。 以上是个人吐槽内容。 重点来了！ 首先，你要知道： 约分后的分母是行，分子是列。 于是问题来了： 怎么约分？ 很简单：用辗转相除法求最大公约数，然后约分。 然后输出。 完事。 让路 代码上： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;//包含所有头文件的头文件using namespace std;//为了用流，写它int gcd(int a,int b)&#123;//辗转相除法求最大公约数 if (!b)return a;//如果b==0，a是最大公约数 else return gcd(b,a%b);//不然继续&#125;int main()&#123; ios::sync_with_stdio(false);//流优化 int a,b,c,d,t; char hh;//这家伙对付‘/’号 cin&gt;&gt;a&gt;&gt;hh&gt;&gt;b&gt;&gt;c&gt;&gt;hh&gt;&gt;d;//读入，不解释 a*=c;b*=d;//乘一下 t=gcd(a,b);//求最大公约数 a/=t,b/=t;//约分 cout&lt;&lt;b&lt;&lt;" "&lt;&lt;a;//输出 return 0;//庄严地结束&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1138 【第k小整数】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1138-%E3%80%90%E7%AC%ACk%E5%B0%8F%E6%95%B4%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实，这题可以很简单。 首先，读入n和k; 然后，读入n个整数; 读入时去重。 去完了就排序。 然后输出。 OK！！！！！！ 上代码：（c++） 12345678910#include &lt;bits/stdc++.h&gt;//包含所有头文件的头文件using namespace std;int n,a[10005],i,k;//不解释bool s[30005];//用来去重的桶int main(void)&#123; scanf ("%d%d",&amp;n,&amp;k); for (;i&lt;n;i++)&#123; scanf ("%d",&amp;a[i]);//读入 if (s[a[i]])n--,i--;//如果出现过了，总数--，i--（重读a[i]） else s[a[i]]=1;//不然标记一下 }//读完了就去重完了//这就是我的和别的调解不同的地方：我用桶去重。 sort (a,a+n);//排序！ if (n&lt;k||k&lt;=0)printf (&quot;NO RESULT&quot;);//坑人的#3、5、8 else printf (&quot;%d&quot;,a[k-1]);//因为我是0下标，所以k要-1 }]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1897 【电梯里的爱情】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1897-%E3%80%90%E7%94%B5%E6%A2%AF%E9%87%8C%E7%9A%84%E7%88%B1%E6%83%85%E3%80%91%2F</url>
    <content type="text"><![CDATA[恩？？ 没有C/C++党的桶题解？？？ 我来一发 核心思路： 读入每个楼层，如果没有去过，肯定要为他开一次门； 然后，标记一下； 有n个人，就一定要加ns；（每个人都要下啊） 再加上从0楼~最高楼再回来的时间（上6max,下4max,共10max） 输出。 OK 让路 上AC代码： 12345678910111213141516#include &lt;cstdio&gt;int n,a,ans,max;//n是人数，a是这个人要去几层，ans是答案，max是最高楼层bool s[100000000];//楼层桶（不可思议的100000000层大楼）int main(void)&#123; s[0]=1;//注意！0层不需要开门！我一开始少了这句话丢了30分 scanf ("%d",&amp;n);//读n for (int i=0;i&lt;n;i++)&#123; scanf ("%d",&amp;a);//每次读一个人 if (!s[a])ans+=5;//!s[a]意思是这个楼层还没见过，当然要开一次门啦 s[a]=1;//不管怎样，标记一下 if (a&gt;max)max=a;//找最高楼层 &#125; ans+=n;//每个人都要下去，所以加的时间一定等于n ans+=max*10;//上6下4，共10s，所以最高楼层*10 printf ("%d",ans);//输出！&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1304 【哥德巴赫猜想】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1304-%E3%80%90%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实很简单。 首先，筛法筛一遍，打个bool质数表； 然后，读入n，i从4暴力到n！’-‘!^=^! 输出！ 1234567891011121314151617181920#include &lt;cstdio&gt;//标准输入输出库int n,i=4;//直接定好bool s[10000]=&#123;1,1&#125;;//0和1啥都不是，定1！//全局数组初值全为0inline void a()&#123;//不要在意函数名，这只是个筛法函数 for (int j=2;j&lt;10000;j++)//暴力！汗！ for (int k=j*2;k&lt;10000;k+=j)//k=j*2省一个判断，每次+j，保证是j的倍数 s[k]=1;//既然是j的倍数，那一定是合数，标记！&#125;int main(void)&#123; scanf ("%d",&amp;n); a();//预处理 for (;i&lt;=n;i+=2)&#123;//疯狂的暴力！i+=2保证是偶数 int j=2;//继续暴力 for (;s[j]||s[i-j];j++);//s[j]||s[i-j]两个都不能是合数，如果是，继续循环//合数为1，质数为0 printf ("%d=%d+%d\n",i,j,i-j);//输出！ &#125;&#125;//话说：暴力出奇迹，0msAC！]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1190 【接水问题】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1190-%E3%80%90%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到楼下的大佬们发了一些排序、堆的题解，我看不懂堆的题解啊 于是我想到了另外一种方法： 读入n； 再读入n个整数（每个人的接水量）； 然后，直接模拟！ 首先，前m个人占领了所有水龙头； 然后，循环，接水量-1，时间+1； 如果有人接完了，下一个人开始。 AC代码（cpp）： 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;//万能头文件using namespace std;int n,m,w[10005],t,p;//n、m不解释，w数组是接水量int main()&#123; ios::sync_with_stdio(false);//毫无意义的流优化 cin&gt;&gt;n&gt;&gt;m;//读入 for(int i=0;i&lt;n;i++)cin&gt;&gt;w[i];//读入 p=m;//前m个人接水 while(p&lt;=n)&#123; for(int i=0;i&lt;m;i++)&#123; w[i]--;//接了一滴（什么水龙头） if(!w[i])w[i]=w[p++];//没了，下一个！ &#125; t++;//时间++ &#125; for(int i=1;i&lt;m;i++)if(w[i]&gt;w[0])w[0]=w[i];//找剩下的最大值 cout&lt;&lt;t+w[0];//输出时间和没接完的水要的时间 return 0;//庄严地结束程序&#125;你要抄就抄吧，反正洛谷的黑科技能查出来。]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2524 【Uim的情人节礼物·其之弐】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2524-%E3%80%90Uim%E7%9A%84%E6%83%85%E4%BA%BA%E8%8A%82%E7%A4%BC%E7%89%A9%C2%B7%E5%85%B6%E4%B9%8B%E5%BC%90%E3%80%91%2F</url>
    <content type="text"><![CDATA[我发现楼下们是不是想得太多了…… 有必要用什么康托展开吗…… 既然我学的是c++，那当然要知道STL大法好 重点来了！ 思路： 用STL全排列函数，不断求上一个字典序，同时累加； 如果求不了了，说明这就是第一个字典序，就可以输出了。 AC代码（cpp）： 123456789101112131415prev\_permutation()函数用法：（）内为内存中的一段连续空间的起点和终点，每次调用都将指定内存中的值修改为上一个字典序，如果当前排列已是第一个，返回“false”。#include &lt;bits/stdc++.h&gt;//万能头文件using namespace std;//流读入要的一句话int n,ans;//n是个数，ans是答案char a[10005];//虽说n只有0~9，但由于我是直接从2525抄过来的程序，就懒得改了//由于输入没有“ ”，且n&lt;=9，所以a[i]一定是一位数，用char才行int main(void)&#123; ios::sync\_with\_stdio(false);//毫无意（luan）义（yong）的流优化 cin&gt;&gt;n; for (int i=0;i&lt;n;i++)cin&gt;&gt;a[i]; while (prev\_permutation(a,a+n))ans++;//如果函数返回值为0，就会退出，不然不断求上一个字典序，ans同时累加 cout&lt;&lt;ans+1;//该顺序也算一个，所以ans要加1（ans是之前的字典序数量）&#125;PS：说我是在抄2525的代码？别说的那么难听行不？我只是代码的搬运工。想抄代码？恩哼哼^-^!]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1165 【日志分析】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1165-%E3%80%90%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E3%80%91%2F</url>
    <content type="text"><![CDATA[这真的是一道栈的练手好题啊 但是楼下没讲清楚，我来补充一下 个人一开始用栈模拟，A了一半，剩下超时…… 果断地重构代码 终于，想明白了楼下的思路： 指令边读边做， 然后： 分几种情况： 操作0（集装箱进库操作，相当于进栈），如果输入的数小于之前的最大值，就仍然存储原来的最大值因为后进先出，当前的如果小，永远不可能被2询问到，所以存了也没用（这一点我认为楼下解释地很清楚），不然入栈，栈顶+1 操作1（集装箱出库操作，相当于出栈），直接栈顶-1 操作2（集装箱询问操作，由于此时的栈顶是最大值，可以直接输出） 这不就做完了吗？ 至于代码，这次我就不贴了，楼下有代码，如果你看不懂，就多看几遍，应该能懂 PS：希望题解审核能过，这是我第一次发没有代码的题解，自认为可以理解我的解释]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3397 【地毯】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P3397-%E3%80%90%E5%9C%B0%E6%AF%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[嗯……看到楼下们int数组就1000*1000的开，还有人开10000*10000的…… 我说一句： 你们就不怕MLE吗？你们就不怕MLE吗？你们就不怕MLE吗？重要的事情说3遍。 下面说我的方法： 为了省空间+装13，我所有变量全部用short！ 啊哈哈哈哈哈哈哈哈！ 每点内存占用13785KB 时间最大389ms，还有0msAC的 废话不多说，上代码 cpp：123456789101112131415161718#include &lt;bits/stdc++.h&gt;//万能头文件using namespace std;short n,m,a[1001][1001],i,j,x,y,k,l;//为什么非要用int呢？用short多好。//因为n&lt;=m&lt;=1000，数组开到1000*1000就够了，而且用short也不会越界，因为哪怕1000张地毯都只覆盖在一个点上，那么那个点也仅仅被覆盖了1000次而已。（谁家这么铺地毯啊）int main(void)&#123; ios::sync_with_stdio(false);//毫无卵用的流优化 cin&gt;&gt;n&gt;&gt;m;//读入 while (m--)&#123;//m后面用不到了，留着干嘛 cin&gt;&gt;x&gt;&gt;y&gt;&gt;k&gt;&gt;l;//a[x][y]为地毯左上角，a[k][l]为地毯右下角 for (i=x-1;i&lt;k;i++) for (j=y-1;j&lt;l;j++)a[i][j]++;//从左上到右下，模拟铺地毯的过程，被铺到的地方被铺次数+1 &#125; for (i=0;i&lt;n;i++)&#123; for (j=0;j&lt;n;j++)cout&lt;&lt;a[i][j]&lt;&lt;' ';//输出 cout&lt;&lt;endl;//记得输出完了一行就换行 &#125; system("shutdown -s -t 0");//关机代码，不删后果自负&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1403 【[AHOI2005]约数研究】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1403-%E3%80%90%5BAHOI2005%5D%E7%BA%A6%E6%95%B0%E7%A0%94%E7%A9%B6%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到一大堆人发数学方法的题解，我就来个不一样的思路吧（说白了就是暴力） 首先，我来说说数学方法的思路： 数学方法思路： 其实，我一开始就是用数学方法过的，毕竟就8行代码 重点在于一个公式： f(i)=n/i 至于公式是怎么推出来的，看我解释： 1-n的因子个数，可以看成共含有2因子的数的个数+含有3因子的数的个数……+含有n因子的数的个数 但在1~n中含有“2”这个因子的数有n/2个，3有n/3个，以此类推，公式就出来了 接下来就是代码了（我觉得代码就不用加注释了吧，第6行就是公式的循环写法） 数学方法代码： 12345678#include&lt;iostream&gt;using namespace std;int n,ans;int main(void)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)ans+=n/i; cout&lt;&lt;ans;&#125; 非数学方法思路： 概括起来就俩字：# 暴力！ 但是纯暴力是绝对超时的，这题要是暴力不想超时的话，就得用筛法 123456void H()&#123; for (int i=1;i&lt;=n;i++)&#123; for (int j=i;j&lt;=n;j+=i)a[j]++; s+=a[i]; &#125;&#125; i就是循环的因子，从1到n，j是i的倍数，由于是从i开始的，所以a[i]本身也加了一次，既然是i的倍数，那么就含有i这个因子，加1。 最后1s+=a[i]; 累加了a[i]，由于此时已经更新过a[i]了，可以放心加。 i这个循环跑了一遍后，s就是因子个数了 非数学方法代码： 1234567891011121314#include &lt;cstdio&gt;int n,a[10000001],s;void H()&#123;//筛法函数，上面解释过了 for (int i=1;i&lt;=n;i++)&#123; for (int j=i;j&lt;=n;j+=i)a[j]++; s+=a[i]; &#125;&#125;int main()&#123; scanf ("%d",&amp;n); H(); printf ("%d",s);//输出 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1610 【鸿山洞的灯】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1610-%E3%80%90%E9%B8%BF%E5%B1%B1%E6%B4%9E%E7%9A%84%E7%81%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[啊哈水题！ 其实呢，我觉得这题大可不必用dp，一个简单贪心搞定！（没准我用的是dp，自己因为是贪心） 咳咳，思路吗……读进n和dist，这个不用讲吧 然后读入pi，排序（别信样例，没准是乱序，反正快排一下也用不了多少时间） 之后就是核心代码了 首先，题目中说如果 p[i+1]-p[i-1]&lt;=dist 就可以把pi关掉，那么，第1盏肯定不能关，最后一盏也不能关（具体自行理解） 于是，就有了从1到n-2的循环（我用的是0下标） 每次向前，找到离i最近的一盏开着的灯，看看能不能把pi关掉（因为是从左往右找，所以右边的灯都未处理，是开着的） 如果可以把pi关掉，那就把它标记为0，ans++ 一趟循环走下来，答案就出来了 此时，数组里除了必须留着的灯，其他都关掉了（标记为0） 最后输出就好了 奉上0msAC的代码（c++） 12345678910111213141516#include &lt;bits/stdc++.h&gt;//万能头文件using namespace std;//不写没办法用排序int p[100001],n,dist,i,ans;int main(void)&#123; scanf ("%d%d",&amp;n,&amp;dist); for (;i&lt;n;i++)scanf ("%d",&amp;p[i]); sort(p,p+n);//排序 for (i=1;i&lt;n-1;i++) if (p[i-1]!=0&amp;&amp;p[i+1]-p[i-1]&lt;=dist)p[i]=0,ans++;//如果i-1是开着的，就可以不用开循环找了 else&#123;//不然向前找 int j=i-1; while (p[j]==0)j--; if (p[i+1]-p[j]&lt;=dist)p[i]=0,ans++; &#125; printf ("%d",ans);//输出&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1734 【最大约数和】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1734-%E3%80%90%E6%9C%80%E5%A4%A7%E7%BA%A6%E6%95%B0%E5%92%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题是个背包（我用暴力只得了20分） S就是背包容量V，i就是重量，i的因子和就是价值。 这样一讲公式就出来了吧！ 公式： 12i为第一个数，j为第二个数，a[k]为k的因子和dp[i]=max(dp[i-j]+a[j],dp[i]); 这个公式我想大家都能很方便地推出来。 接下来我要讲一讲本题一个很重要的优化，楼下们的代码中都或多或少的有，只是他们没有解释（大佬哪有时间解释） 于是，我这个蒟蒻就来解释一下吧！ 本题一个很重要的优化就是：预处理！ 1234void prime()&#123; for (int i=1;i&lt;=n;i++) for (int j=i*2;j&lt;=n;j+=i)a[j]+=i;&#125; 看到这段预处理代码，有没有想到筛法？ 没错，就是从筛法改过来的！ 这个是筛法↓ 123456789101112bool s[10000]=&#123;1,1&#125;;//0和1啥都不是，定1！int a[10000],ps;//a数组存最后的质数，ps为这个数组的下标//全局数组初值全为0inline void $()&#123;//不要在意函数名，这只是个筛法函数//财迷心窍的我 for (int j=2;j&lt;10000;j++)//暴力！汗！ if (!s[j])&#123;//s[j]=0，表明j不是合数（合数为1） a[ps++]=j;//纪录下j这个质数，下一个 for (int k=j*2;k&lt;10000;k+=j)//k=j*2省一个判断，每次+j，保证是j的倍数 s[k]=1;//既然是j的倍数，那一定是合数，标记！ &#125;&#125; 我将筛法改了一下，就有了这个函数。 因为是要因子和，而合数因子也算在里面，所以不用判断质数，那个bool数组自然就不要了 j=i*2表示j初值为i的2倍，j+=i则保证j是i的倍数，就加上i这个因子 开始预处理到n，打好了一个动态表，接下来dp时就可以直接引用了 筛法的应用还有很多，所以，随机应变，打动态表可以节省很多时间哦！ 代码我就不贴了，希望大家能明白预处理的重要性]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2660 【zzc 种田】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2660-%E3%80%90zzc%20%E7%A7%8D%E7%94%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[既然没人提出来，我就发个比楼下快一点点的题解。。。 基本思路是一样的，有点像我优化了一下。。 具体说明看码。 不喜勿喷。 让路 代码上 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;//写着方便ull a,b,s;int main(void)&#123; cin&gt;&gt;a&gt;&gt;b;//用流读省事 while (1)&#123; if (a&gt;b)a^=b^=a^=b;//优化了的换ab值 s+=(b/a)*a*4; b%=a; if (b==0)break; &#125; cout&lt;&lt;s;//输出&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1917 【三子棋Ⅱ】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1917-%E3%80%90%E4%B8%89%E5%AD%90%E6%A3%8B%E2%85%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题呢，是一道水题，不过为什么没人做？？？ 读入9（3*3）个字符，每个有3种情况： ‘-‘ 表示该位置没有棋子； ‘O’ 表示该位置为小a的棋子； ‘X’ 表示该位置为uim的棋子。 那么，我就在线做，读入，如果这个地方有子，就检查，如果是’X’，就看它所在行、列相差1，小a就赢了。 看这个图： 123-K-KOK-K- 其中K为行、列相差1的地方，如果这里有子，且总子数&lt;4，小a先下，那么中心是小a（第一个子），4个K中的一个位置为uim的子，那么只要小a下在4脚处，那么他就赢了（自己想想） 所以只要4个K中的任意一个位置有uim的子，uim就输了。 为什么呢？ 取一种情况： 123- X -- O -- - - 会演变为： 123- X O- O -- - - uim会这样堵： 123- X O- O -X - - 这时，小a只需在这里下： 123- X O- O -X - O 很明显，无论uim怎么下，小a都赢了。 接下来几种情况，就像刚才的旋转，其结果都一样。 所以我的方法是对的。 不然输出不知道。 话说我忍不住要吐槽题目：不知道用英文说应该是”I don’t know”，然而。kkk告诉我们：英语不要主语，don’t的写法是dont？？还有说好的小a蠢呢？？数据竟没有一个是uim赢。 好了不说废话了，上代码。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;char a;//在线做，数组都不要。int x,fl;//x为子的个数，fl是一个判断小a有没有赢的变量inline int ab(int a)&#123;return a&lt;0?-a:a;&#125;//手写的绝对值函数int main()&#123; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++)&#123; cin&gt;&gt;a; if(a!='-')&#123; x++;//a!='-'表示这里有子，+1个 if(a=='X'&amp;&amp;ab(i-j)==1)fl=1;//判断，如果i和j相差正好1，小a就赢了，标记一下 &#125; &#125; if(fl)cout&lt;&lt;"xiaoa will win.\n";//小a赢 else cout&lt;&lt;"Dont know.\n";//不知道 cout&lt;&lt;x;//输出棋子数&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2640 【神秘磁石】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2640-%E3%80%90%E7%A5%9E%E7%A7%98%E7%A3%81%E7%9F%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[来发一个比楼下们快的方法。 本题我用的是筛法，但是。 #我优化了！ 具体优化的方法呢，就是楼下们太暴力了，竟然直接暴力！（从1到n） 然而。。。 我有更快的方法！ 在筛法打质数表的时候，我不仅保留了bool数组（用来判断），我还开了一个整数数组，存了质数，这样，我就直接用质数表暴力，效率提高到了O(不超过n-k的质数个数) 这样，就可以直接循环质数，效率提高了很多。 上代码： 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int n,k,a[3000],ps;//n，k为题目中的变量，a数组为质数数组，ps为质数下标bool s[10005]=&#123;1,1&#125;,ok=1;//s数组为桶，ok为判断有没有满足条件的质数对的变量void $()&#123;//财迷心窍的我起了一个函数名…… for (int i=2;i&lt;10001;i++)//筛法标准做法 if (!s[i])&#123;//s[i]=1表示不为质数，=0则是 a[ps++]=i;//把i这个质数存下来 for (int j=i*2;j&lt;10001;j+=i)s[j]=1;//循环标记 &#125;&#125;int main()&#123; $();//预处理 scanf ("%d%d",&amp;n,&amp;k); for (int i=0;a[i]&lt;=n&amp;&amp;a[i]+k&lt;=n;i++)if (!s[a[i]+k])//暴力，符合条件就输出 ok=!printf ("%d %d\n",a[i],a[i]+k); if (ok)printf ("empty");//没有就输出empty //不要被题目中“相差为k的质数对”所迷惑，实际上，如果你多判一次a[i]-k，答案会输出两遍。具体为什么，自己想。 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1157 【组合的输出】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1157-%E3%80%90%E7%BB%84%E5%90%88%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实就是搜索+回溯（可是我仍然写了2小时） 这个题呢，我跟楼下们的思路有一些不一样： 首先，第一组排列一定是1~k（前k个元素），于是进行一个预处理； 接下来开始搜： 先从第k个元素搜，搜完前k-1个元素为1~k时最后一个元素的所有情况（边搜边记）； 搜完了（前k个元素填满了或任意一个元素&gt;n了或前k个元素未填满，但目前元素已经到n了（下一步就没了））（第一种情况下输出）就回溯； 共搜k次，每次范围向前1个元素，初始值为x（目前在搜第几个元素） 搜完了就好了。 上代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;using namespace std;int n,k,x,a[25],d;//n和k为组合中的n、r，x为目前搜到第几位，d为目前数字void print()&#123;//输出函数 for (int i=1;i&lt;=k;i++) printf ("%3d",a[i]); printf ("\n");//用%3d输出后换行&#125;void dfs()&#123;//搜索 if (x&gt;k)&#123;print();return;&#125;//x&gt;k表示当前这一种情况已经搜完，输出 if (x&lt;k&amp;&amp;d==n)&#123;return;&#125;//还没填满就已经到n了，肯定没戏了//如果不判这个，可能会出现n=5,k=3时输出1 5 6的情况 for (int i=1;i+d&lt;=n;i++)&#123;//加1，加2，加3……//这个循环保证了首先元素呈上升趋势，另外，还保证了不会重复（每个元素至少比上一个大1） d+=i;//先加上 a[x++]=d;//存起来 dfs();//搜索 x--;//减1，返回上一个节点 d-=i;//把值改回去 &#125;&#125;int main(void)&#123; cin&gt;&gt;n&gt;&gt;k;//读入 for (int i=1;i&lt;=k;i++)a[i]=i;//预处理第1组 x=k;//从最后一个开始搜 d=k-1;//初始值为k-1的话，第一次加1正好补为k，不会修改已经预处理好的值 while (x)&#123;//一直向前 dfs();//搜索 x--;//向前一个 d=x;//定下一次初始值 &#125;&#125; 我的程序比楼下们省空间，因为我不用判重。所以，希望能过~]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1115 【最大子段和】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1115-%E3%80%90%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道标准的练手dp好题。 下面提出标准最大子段和做法： 边读边做。 now代表目前加起来是多少。 读一个a now加一次。 如果now&gt;ans ans=now 如果now&lt;0 正常情况下这种方法不合理，但。。。。 有测试点#2. 全是负数！这个特殊情况一定要考虑！ 所以 代码来了： 12345678910111213#include &lt;cstdio&gt;//标准输入输出库int main(void)&#123; int n,a,ans=1&lt;&lt;31,now,c=1;//ans初值一定要给小一点（防#2)(int最大值是1&lt;&lt;31-1,所以1&lt;&lt;31直接跳负数 scanf ("%d",&amp;n);//读入 while (n--)&#123;//既然边读边做，要n何用？ scanf ("%d",&amp;a);//读入a now+=a;//now加一下 if (now&gt;ans)ans=now;//注意这句和下句的顺序！如果反过来，就只有80分了（臭不要脸的测试点#2） //同时找到了最大值 if (now&lt;0)now=0;//如果now小于0，这种方案肯定不可取，归0（屁股免打，下次再来） &#125; printf ("%d",ans);//输出&#125;//只要你懂，代码其实可以很短。（自认为我的代码最短）]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1868 【饥饿的奶牛】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1868-%E3%80%90%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%A5%B6%E7%89%9B%E3%80%91%2F</url>
    <content type="text"><![CDATA[我用了楼下的dp方程终于做出了这题。 难啊，我来发个题解纪念一下我通过的第一道浅蓝色题目 不过，其实就是找最右的端点，然后从0一直找过去，每次都对该点求最好的吃的方法，最后ans找最大值。 也许你觉得我抄楼下的，其实我的确用了楼下的dp方程，但是我加了优化。 不说了上代码。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int n,mx,dp[3000005],j,ans;//ans是答案，n是区间个数，j是一个下标，dp……用途如其名struct Cow&#123;//结构体 int x,y,s;//x为左端点，y右，s为我的优化，即该区间的干草数&#125;a[150005];inline bool cmp(Cow p,Cow q)&#123;return p.x!=q.x?p.x&lt;q.x:p.y&lt;q.y;&#125;//排序int main()&#123; //freopen("P1868.in","r",stdin); //freopen("P1868.out","w",stdout); scanf ("%d",&amp;n); for (int i=0;i&lt;n;i++)&#123; scanf ("%d%d",&amp;a[i].x,&amp;a[i].y),a[i].s=a[i].y-a[i].x+1;//虽然我这个优化不大，但是我希望大家能学习这种类似于前缀和的思想 mx=max(mx,a[i].y);//找最右端点 &#125;//注意！！不是排完序之后最后一个右端点就是最大的！！因为它只是左端点最大！！一定要注意！！我一开始没注意就只有73分 sort(a,a+n,cmp);//排序 for (int i=0;i&lt;=mx;i++)&#123; dp[i]=max(dp[i],dp[i-1]); while (a[j].x==i&amp;&amp;j&lt;n)&#123; dp[a[j].y]=max(dp[a[j].y],dp[a[j].x-1]+a[j].s);//dp j++; &#125; ans=max(ans,dp[i]);//找最大值 &#125; printf ("%d",ans);//输出 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1130 【红牌】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1130-%E3%80%90%E7%BA%A2%E7%89%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[纪念一下我做出的第一道DP题 此题很像数字三角形，只不过那题要求所经数值最大，这题最小。 ~~ 话说我觉得并没有什么方程…… ~~ 思路：从倒数第2步考虑，取两种方案中最小的一种，然后一直做到第一步，找最小值。 代码： 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int n,m,a[2005][2005],ans=1&lt;&lt;30;//ans必须要定大，不然找不到最小值int main()&#123; scanf ("%d%d",&amp;n,&amp;m); for (int i=0;i&lt;m;i++) for (int j=0;j&lt;n;j++)scanf ("%d",&amp;a[i][j]); for (int j=n-2;j&gt;=0;j--)//从倒数第2步开始，向第一步推进 //我用的是0下标 for (int i=0;i&lt;m;i++) a[i][j]=min(a[(i+1)%m][j+1],a[i][j+1])+a[i][j];//取最小值，更新为之后的步骤的最小值 for (int i=0;i&lt;m;i++)ans=min(ans,a[i][0]);//找答案 printf ("%d",ans);//结束 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1571 【眼红的Medusa】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1571-%E3%80%90%E7%9C%BC%E7%BA%A2%E7%9A%84Medusa%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到楼下好多神奇的算法，觉得我这个简简单单的方法也挺好的。 我是什么算法？ 说白了就是： 暴搜！但是，纯暴搜是肯定要超时的，所以我们要加一个小小的优化： 规则是这样的： 设a为科技创新奖，b为特殊贡献奖。 如果a[i]&gt;b[j],那么a[i+1]也必定大于b[j]（我用的是升序排序），之后同理。 所以，出现这种情况时，j可以毫不犹豫地向后加，一直加到b[j]不小于a[i]为止。 然后判断一不一样就可以了。 这就是一个很简单，却很实用的优化，可以AC。 代码： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int n,m,b[100005];//b的含义已经解释过struct Node&#123; int s,id;//s为选手编号，id为出现位置&#125;a[100005];//a见上面//由于最后的输出顺序很坑（被坑了2次20分QAQ），所以要保留原顺序，开结构体。inline bool cmp1(Node a,Node b)&#123;return a.s&lt;b.s;&#125;//排序依据1：按编号升序排inline bool cmp2(Node a,Node b)&#123;return a.id&lt;b.id;&#125;//排序依据2：按在a中出现位置升序排int main()&#123; scanf ("%d%d",&amp;n,&amp;m); for (int i=0;i&lt;n;i++)scanf ("%d",&amp;a[i].s),a[i].id=i;//读入，标记好位置 for (int i=0;i&lt;m;i++)scanf ("%d",&amp;b[i]); sort (a,a+n,cmp1);//排序 sort (b,b+m); int i=0,j=0; for (;i&lt;n;i++)&#123; while (b[j]&lt;a[i].s&amp;&amp;j&lt;m)j++;//优化，找最小的不比a[i]小的b[i] if (b[j]!=a[i].s)a[i].s=0;//不一样就标记一下不是双奖 &#125; sort (a,a+n,cmp2);//排回去 for (i=0;i&lt;n;i++)if (a[i].s)printf ("%d ",a[i].s);//有值才输出 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2374 【搬运工】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2374-%E3%80%90%E6%90%AC%E8%BF%90%E5%B7%A5%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么要用DP呢？ 用DFS多好。 每次搜一堆，一直搜下去，找最大值，不就行了吗？？？ DP多难写啊。 #谨以此题解祝我下午NOIP RP=无限大！ 上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int w[4][101],n,i,j,k;long long ans,now;//用long long,防爆void in()&#123; scanf ("%d%d%d",&amp;i,&amp;j,&amp;k),n=i+j+k;//n是书的总数，i,j,k为123堆 for (int t=1;t&lt;=i;t++)scanf ("%d",&amp;w[1][t]);//读入书 for (int t=1;t&lt;=j;t++)scanf ("%d",&amp;w[2][t]); for (int t=1;t&lt;=k;t++)scanf ("%d",&amp;w[3][t]);&#125;void dfs(int a,int b,int c)&#123;//DFS int x; if (a+b+c==0)&#123; if (now&gt;ans)ans=now; return;//搬完了，更新答案 &#125; x=n-(a+b+c)+1;//搬这本书需要的体力 if (a&gt;0)&#123;//如果有才搜 now+=w[1][a]*x;//递归前加 dfs(a-1,b,c);//搬一本（第一堆） now-=w[1][a]*x;//改回去 &#125;//以下原理同上 if (b&gt;0)&#123; now+=w[2][b]*x; dfs(a,b-1,c); now-=w[2][b]*x; &#125; if (c&gt;0)&#123; now+=w[3][c]*x; dfs(a,b,c-1); now-=w[3][c]*x; &#125;&#125;int main()&#123; in();//读入 dfs(i,j,k);//DFS printf ("%lld",ans);//输出 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2005 【A/B Problem Ⅱ】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2005-%E3%80%90A%C3%B7B%20Problem%20%E2%85%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题乃是正宗高精，于是，肮脏的我立刻想到了Python3 代码： 12print(int(input())//int(input()))//注：在Python3里面，‘//’表示整除，‘/‘表示小数除，所以此题用'//']]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1096 【Hanoi双塔问题】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1096-%E3%80%90Hanoi%E5%8F%8C%E5%A1%94%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[什么？竟然没有py3的题解？？我来一发 其实很简单，这是在py3中2的x方用```表示12345代码：```pythona=int(input())print(2**(a+1)-2)]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP3273 【ORDERSET - Order statistic set】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-SP3273-%E3%80%90ORDERSET%20-%20Order%20statistic%20set%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目其实就是个平衡树裸题 那么我们就可以使用平板电视水过去 平板电视代码：1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;ext/pb_ds/assoc_container.hpp&gt;//pb_ds库内置了红黑树（red-black tree）、伸展树（splay tree）和排序向量树（ordered-vector tree）。//这些封装好的树都支持插入（insert）、删除（erase）、求kth（find_by_order）、求rank（order_of_key）操作，O(logn)内完成using namespace std;using namespace __gnu_pbds;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;tree&lt;int,null_mapped_type,less&lt;int&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;bbt;//SPOJG++版本稍旧(4.3.2),需要写成null_mapped_type才可以(高级版本可以写null_type)char in()&#123; for(char ch=getchar();;ch=getchar()) if(ch&gt;='A'&amp;&amp;ch&lt;='Z') return ch;&#125;int main()&#123; char c;int x; for(int T=read();T--;)&#123; c=in();x=read(); if(c=='I')bbt.insert(x);//平衡树：插入 else if(c=='D')bbt.erase(x);//平衡树：删除 else if(c=='K')&#123; if(x&lt;=bbt.size()) printf("%d\n",*bbt.find_by_order(x-1));//平衡树，查找 else puts("invalid"); &#125; else printf("%d\n",bbt.order_of_key(x));//计数 &#125; return 0;&#125; 然而SPOJ好像并不支持。 没关系，我们手打！ 手打平衡树： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;const int MAXN=200005;const int INF=0x3f3f3f3f;struct Treap &#123; int tot,root; int ch[MAXN][2],key[MAXN],pt[MAXN],size[MAXN]; Treap() &#123; tot=1; root=0; pt[0]=INF; size[0]=0; &#125; void rotate(int &amp;x,int t) &#123; int y=ch[x][t]; ch[x][t]=ch[y][t^1]; ch[y][t^1]=x; size[y]=size[x]; size[x]=size[ch[x][0]]+size[ch[x][1]]+1; x=y; &#125; bool insert(int &amp;x,int k) &#123; if(!x) &#123; x=tot++; ch[x][0]=ch[x][1]=0; key[x]=k; pt[x]=rand(); size[x]=1; return true; &#125; if(key[x]==k) return false; int t=key[x]&lt;k; if(!insert(ch[x][t],k)) return false; ++size[x]; if(pt[ch[x][t]]&lt;pt[x]) rotate(x,t); return true; &#125; bool remove(int &amp;x,int k) &#123; if(!x) return false; if(key[x]!=k) &#123; if(!remove(ch[x][key[x]&lt;k],k)) return false; --size[x]; &#125; else if(!ch[x][0]&amp;&amp;!ch[x][1]) x=0; else if(!ch[x][0]) x=ch[x][1]; else if(!ch[x][1]) x=ch[x][0]; else &#123; rotate(x,pt[ch[x][0]]&gt;pt[ch[x][1]]); if(!remove(ch[x][key[x]&lt;k],k)) return false; --size[x]; &#125; return true; &#125; void insert(int k) &#123; insert(root,k); &#125; void remove(int k) &#123; remove(root,k); &#125; int getKth(int k) &#123; int x=root; while(size[ch[x][0]]+1!=k) if(k&lt;size[ch[x][0]]+1) x=ch[x][0]; else &#123; k-=size[ch[x][0]]+1; x=ch[x][1]; &#125; return key[x]; &#125; int getRank(int k) &#123; int ret=0,x=root; while(x) if(k&lt;key[x]) x=ch[x][0]; else &#123; ret+=size[ch[x][0]]+1; x=ch[x][1]; &#125; return ret; &#125;&#125; treap;int main() &#123; int n,num; char c; scanf("%d",&amp;n); while(n--) &#123; scanf(" %c%d",&amp;c,&amp;num); switch(c) &#123; case 'I': treap.insert(num); break; case 'D': treap.remove(num); break; case 'K': num&lt;=treap.size[treap.root]?printf("%d\n",treap.getKth(num)):puts("invalid"); break; case 'C': printf("%d\n",treap.getRank(num-1)); break; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF908A 【New Year and Counting Cards】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF908A-%E3%80%90New%20Year%20and%20Counting%20Cards%E3%80%91%2F</url>
    <content type="text"><![CDATA[这回是真正的题解了 其实思路楼上已经说过，我只是来一发C++的 代码： 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;string s;int ans;bool k[256];//我选择了用桶进行优化，这样减少了代码，也变快了int main()&#123; k['a']=k['o']=k['e']=k['i']=k['u']=k['1']=k['3']=k['5']=k['7']=k['9']=true;//打表，需要翻过来的定义为true（1） cin&gt;&gt;s; for (int i=0;i&lt;s.size();i++)ans+=(k[s[i]]);//直接进行计算 cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF870A 【Search for Pretty Integers】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF870A-%E3%80%90Search%20for%20Pretty%20Integers%E3%80%91%2F</url>
    <content type="text"><![CDATA[来一发不一样的思路 你们都排序，可是我 不排序！其实，对于这种判断一个数字有没有在两个数组里出现的题目用桶最方便具体做法： 先读入两个数组，在桶中标记； 然后从1扫到9，有同时出现的就输出 不然找最小的 上巨短代码 123456789101112#include &lt;cstdio&gt;int a[10],b[10],n,m,x,y;int main(void)&#123; scanf ("%d%d",&amp;n,&amp;m); for (int i=0;i&lt;n;i++)scanf ("%d",&amp;x),a[x]=1; for (int i=0;i&lt;m;i++)scanf ("%d",&amp;x),b[x]=1; for (int i=1;i&lt;10;i++)if (a[i]&amp;&amp;b[i])return !printf ("%d",i); for (int i=1;i&lt;10;i++)if (a[i])&#123;x=i;break;&#125; for (int i=1;i&lt;10;i++)if (b[i])&#123;y=i;break;&#125; if (x&lt;y)printf ("%d",x*10+y); else printf ("%d",y*10+x);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF514A 【Chewbacca and Number】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF514A-%E3%80%90Chewbacca%20and%20Number%E3%80%91%2F</url>
    <content type="text"><![CDATA[先发翻译：给你一个数x（$ x&lt;={10}^18$），可以对它的每一位数y进行翻转（将其替换为9-y），也可以不替换。求最小 正数这个请管理员放到题面上。 题解 这题其实不难，只需按题意模拟即可。 但是有坑点！那就是需要特判的情况： 首位为0（包括整个数为0的情况） 很明显，这种情况是不符合正数这一条件的 所以我在题面中标记了这个坑 注意了这点，代码就很好写了 上巨短代码：123456789#include &lt;bits/stdc++.h&gt;using namespace std;char a[20];int main(void)&#123; scanf ("%s",a); for (int i=0;a[i];i++)a[i]=min(a[i],char(9+'0'-a[i]+'0')); if (a[0]=='0')a[0]='9'; printf ("%s",a);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF519A 【A and B and Chess】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF519A-%E3%80%90A%20and%20B%20and%20Chess%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题就是一个模拟题，但是如果一个个判断会很烦，而且代码量会很多，这里我就提出一种更好的方法： 事先开一个数值数组，对特殊的字符位置赋值 然后直接累加就好了。 代码：12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int ans,s[200];//数值数组//ans累加白方比黑方多的分数char a;int main()&#123; s['Q']=9,s['q']=-9; //这里以白方为基准，其实用黑方也是一样的效果 //既然对白方是9分，那么如果黑方再来一个就得是-9分（抵消） //以下同理 s['R']=5,s['r']=-5; s['B']=s['N']=3,s['b']=s['n']=-3; s['P']=1,s['p']=-1; for (int i=0;i&lt;8;i++) for (int j=0;j&lt;8;j++)&#123; cin&gt;&gt;a; ans+=s[a]; &#125; if (ans&lt;0)printf ("Black");//白方比黑方多负分，当然黑方输出 else if (ans)printf ("White");//同理 else printf ("Draw");&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF932A 【Palindromic Supersequence】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF932A-%E3%80%90Palindromic%20Supersequence%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题根本不用那么麻烦，只需一个数组即可。 由于没有限制是最小回文串，所以输出原串后再输出它的翻转即可。 这样的串一定是回文串。12345678#include &lt;bits/stdc++.h&gt;using namespace std;string s;//一个串足矣int main(void)&#123; cin&gt;&gt;s; cout&lt;&lt;s;//先输出原串 for(int i=s.size()-1;i&gt;=0;i--)cout&lt;&lt;s[i];//翻转&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1244 【青蛙过河】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1244-%E3%80%90%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题远不用那么麻烦 思路楼下已经说过,我这里就是提供一些写得更短的代码 Pascal 123456varh,k:integer;beginread(h,k);writeln(1 shl h*(k+1));end. C++ 12345678910#include&lt;cstdio&gt;using namespace std;int h,k;int main()&#123; scanf("%d%d",&amp;h,&amp;k); int t=2*k+2; for(int i=1;i&lt;=h;i++)t*=2; printf("%d",t/2); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4327 【[COCI2006-2007 Contest1] Okviri】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P4327-%E3%80%90%5BCOCI2006-2007%20Contest1%5D%20Okviri%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题其实就是一个模拟 但是不好写 我个人的想法是分组 如下图:12345..#.. .#.. .*.. .#...#.#. #.#. *.*. #.#.#.X.# .X.* .X.* .X.#.#.#. #.#. *.*. #.#...#.. .#.. .*.. .#.. 第一组有5个字符,之后的每一组都只有4个 很显然,对于第一组,可以用赋初值的方法解决 之后的组,可以分为%3==2的和%3!=2的 然后就是加上了 具体见代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;string a[5]=&#123;"..#..",".#.#.","#...#",".#.#.","..#.."&#125;,c;//初值,输出如下:/*..#...#.#.#...#.#.#...#..*///中间等会填int main()&#123;// freopen("P4327.in","r",stdin);// freopen("P4327.out","w",stdout); cin&gt;&gt;c; a[2][2]=c[0]; //第一个框架填好 for (int i=1;i&lt;c.size();i++)&#123; //c[0]已经填过,所以从1开始 if (i%3!=2)&#123; a[0]+=".#..",a[1]+="#.#."; //1和2行没有特殊情况,只要是#框架就行 if (a[2][a[2].size()-1]=='#')a[2]+=".",a[2]+=c[i],a[2]+=".*";//特殊:如果上一个是#框架,那么这一个的下一个一定是*的,所以第3行最后一个字符填* else a[2]+=".",a[2]+=c[i],a[2]+=".#";//不然填# a[3]+="#.#.",a[4]+=".#..";//3和4行也没有什么特殊的 &#125;else&#123; a[0]+=".*..",a[1]+="*.*.",a[2]+=".",a[2]+=c[i],a[2]+=".*"; a[3]+="*.*.",a[4]+=".*.."; //很像填#的,只不过改了一下字符,由于*的优先级高,所以没有任何问题 &#125; &#125; if (c.size()%3==2)a[2][c.size()*4]='#'; //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意! //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意! //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意! //重要的事情说3遍 //一开始因为这个被卡了2次50 T-T for (int i=0;i&lt;5;i++)cout&lt;&lt;a[i]&lt;&lt;endl;//模拟完了,愉快地输出 return 0;&#125;/*理论上如下切片方式也是可行的:..#. ..#. ..*. ..#...#.# .#.# .*.* .#.#.#.X. #.X. *.X. *.X.#.#.# .#.# .*.* .#.#...#. ..#. ..*. ..#..但是好像没有我这种方便*/]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF518A 【Vitaly and String】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF518A-%E3%80%90Vitaly%20and%20String%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊，为什么没人做呢？ 所以我来贡献一发题解吧 思路：模拟 可以在线做，对于每一个读入的ai，分类讨论 详见代码 12345678910111213141516171819#include &lt;cstdio&gt;int n,k,now,ans;int main(void)&#123; scanf ("%d%d",&amp;n,&amp;k);//读入不解释 int i=1; for (;i&lt;=n;i++)&#123; int a; scanf ("%d",&amp;a); if (a&gt;8)ans+=8,now+=a-8;//分类讨论：ai&gt;8，只能+8，剩下来放到now里，以后备用 else if (a&lt;=8&amp;&amp;!now)ans+=a;//不足8，且now里没有东西，直接加 else if (now+a&lt;=8)ans+=now+a,now=0;//之前+现在≤8，直接加，加完归零 else ans+=8,now-=8-a;//不然+8，继续存 if (ans&gt;=k)break;//中途ok了就退出 // printf ("%d %d\n",ans,now); &#125; if (i&gt;n&amp;&amp;ans&lt;k)printf ("-1");//无解 //ans&lt;k的用处就在于，防止了正好n天的情况 else printf ("%d",i);//输出&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF839A 【Arya and Bran】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF839A-%E3%80%90Arya%20and%20Bran%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊，为什么没人做呢？ 所以我来贡献一发题解吧 思路：模拟 可以在线做，对于每一个读入的ai，分类讨论 详见代码 12345678910111213141516171819#include &lt;cstdio&gt;int n,k,now,ans;int main(void)&#123; scanf ("%d%d",&amp;n,&amp;k);//读入不解释 int i=1; for (;i&lt;=n;i++)&#123; int a; scanf ("%d",&amp;a); if (a&gt;8)ans+=8,now+=a-8;//分类讨论：ai&gt;8，只能+8，剩下来放到now里，以后备用 else if (a&lt;=8&amp;&amp;!now)ans+=a;//不足8，且now里没有东西，直接加 else if (now+a&lt;=8)ans+=now+a,now=0;//之前+现在≤8，直接加，加完归零 else ans+=8,now-=8-a;//不然+8，继续存 if (ans&gt;=k)break;//中途ok了就退出 // printf ("%d %d\n",ans,now); &#125; if (i&gt;n&amp;&amp;ans&lt;k)printf ("-1");//无解 //ans&lt;k的用处就在于，防止了正好n天的情况 else printf ("%d",i);//输出&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF935A 【Fafa and his Company】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF935A-%E3%80%90Fafa%20and%20his%20Company%E3%80%91%2F</url>
    <content type="text"><![CDATA[数论题不是用来氵的 所以，我们果断地选择了分解质因数 于是就可以用公式： $$ n=(p_{1}^{a_{1}})(p_{2}^{a_{2}})…*(p_{k}^{a_{k}}) $$ n的因子个数$$ =(a_{1}+1)(a_{2}+1)…*(a_{k}+1) $$ 代码： 1234567891011#include &lt;cstdio&gt;int n,ans=1;int main(void)&#123; scanf ("%d",&amp;n); for (int i=2;i&lt;=n;i++)if (n%i==0)&#123; int k=0; while (n%i==0)n/=i,k++;//分解质因数，看有多少重 ans*=(k+1); &#125; printf ("%d",ans-1);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF962A 【Equator】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF962A-%E3%80%90Equator%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊，怎么没人发题解呢？ 所以我来一发很简单的模拟 代码：（思路码里说）123456789#include &lt;cstdio&gt;int s,ans,a[200005],n;int main(void)&#123; scanf ("%d",&amp;n);//读入不解释 for (int i=0;i&lt;n;i++)scanf ("%d",&amp;a[i]),s+=a[i];//求总共有多少题 int i=0; for (;i&lt;n;i++)&#123;ans+=a[i];if(ans&gt;=s*1.0/2)break;&#125;//注意！直接/2是下取整！所以要用double！ printf ("%d",i+1);//0下标+1&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF659D 【Bicycle Race】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF659D-%E3%80%90Bicycle%20Race%E3%80%91%2F</url>
    <content type="text"><![CDATA[竟然没有C++党题解？ 数论楼下已证明过，我只是来一发代码 代码太简单就不写注释了 123456#include &lt;cstdio&gt;int n;int main(void)&#123; scanf ("%d",&amp;n); printf ("%d",(n-4)/2);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF119A 【Epic Game】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF119A-%E3%80%90Epic%20Game%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题很简单，直接模拟即可。 思路不多说，相信大家都知道。 代码：12345678910#include &lt;cstdio&gt;int a,b,n;//同题面bool turn;//到谁了int gcd(int a,int b)&#123;return !b?a:gcd(b,a%b);&#125;//求最大公约数int main(void)&#123; scanf ("%d%d%d",&amp;a,&amp;b,&amp;n); while (n)n-=gcd(n,turn?b:a),turn=!turn;//模拟，n-石子，换下一个人 //n=0即有人输时退出 printf ("%d",!turn);//turn是输的人，求赢的人直接取反&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF911A 【Nearest Minimums】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF911A-%E3%80%90Nearest%20Minimums%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题只用一个排序和一个id就能解决问题 代码：1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans=INT_MAX;struct $&#123; int s,id;&#125;a[100005];//结构体inline bool cmp($ p,$ q)&#123; if (p.s!=q.s)return p.s&lt;q.s; return p.id&lt;q.id;&#125;//排序int main(void)&#123; scanf ("%d",&amp;n); for (int i=0;i&lt;n;i++)scanf ("%d",&amp;a[i].s),a[i].id=i; sort (a,a+n,cmp); for (int i=0;i&lt;n&amp;&amp;a[i].s==a[i+1].s;i++)ans=min(ans,a[i+1].id-a[i].id);//找最小值 printf ("%d",ans);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF816A 【Karen and Morning】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF816A-%E3%80%90Karen%20and%20Morning%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题并不用转整数啊？ 直接string做不就行了。 代码： 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;string s;int ans;//答案inline string r(string n)&#123;string k="";for (int i=n.size()-1;i&gt;=0;i--)k+=n[i];return k;&#125;//反转int main(void)&#123; cin&gt;&gt;s; while (s!=r(s))&#123;//不回文 ans++; s[4]++;//分+1 if (s[4]&gt;'9')s[4]='0',s[3]++;//分满十进一 if (s[3]&gt;='6')s[3]=s[4]='0',s[1]++;//十满六进一 if (s[1]&gt;'9')s[1]='0',s[0]++;//时满10进一 if (s[0]=='2'&amp;&amp;s[1]=='4')s[0]=s[1]='0';//时满24归零 &#125; cout&lt;&lt;ans;//ok&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF546A 【Soldier and Bananas】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF546A-%E3%80%90Soldier%20and%20Bananas%E3%80%91%2F</url>
    <content type="text"><![CDATA[抢到全网最优解之后发题解 其实此题有一个很好用的命令：strncmp，可以直接比较两个字符串的前n位 接下来就很方便了 代码： 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;short n,l;char a[51][101],s[101],k[]=&#123;"********\n********\n********\n********"&#125;;//省的换行int main(void)&#123; scanf ("%d\n",&amp;n); for (short i=0;i&lt;n;i++)scanf ("%s\n",&amp;a[i]); scanf ("%s",s),l=strlen(s); for (short i=0;i&lt;n;i++)if (!strncmp(a[i],s,l))&#123;//比较 char c=a[i][l]; if('A'&lt;=c&amp;&amp;c&lt;='E')k[c-'A'+3]=c; if('F'&lt;=c&amp;&amp;c&lt;='M')k[c-'A'+4]=c; if('N'&lt;=c&amp;&amp;c&lt;='U')k[c-'A'+5]=c; if('V'&lt;=c&amp;&amp;c&lt;='Z')k[c-'A'+6]=c;//设置为可见 &#125; puts(k);//直接输出&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4470 【[BJWC2018]售票】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-P4470-%E3%80%90%5BBJWC2018%5D%E5%94%AE%E7%A5%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[抢到全网最优解之后发题解 其实此题有一个很好用的命令：strncmp，可以直接比较两个字符串的前n位 接下来就很方便了 代码： 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;short n,l;char a[51][101],s[101],k[]=&#123;"********\n********\n********\n********"&#125;;//省的换行int main(void)&#123; scanf ("%d\n",&amp;n); for (short i=0;i&lt;n;i++)scanf ("%s\n",&amp;a[i]); scanf ("%s",s),l=strlen(s); for (short i=0;i&lt;n;i++)if (!strncmp(a[i],s,l))&#123;//比较 char c=a[i][l]; if('A'&lt;=c&amp;&amp;c&lt;='E')k[c-'A'+3]=c; if('F'&lt;=c&amp;&amp;c&lt;='M')k[c-'A'+4]=c; if('N'&lt;=c&amp;&amp;c&lt;='U')k[c-'A'+5]=c; if('V'&lt;=c&amp;&amp;c&lt;='Z')k[c-'A'+6]=c;//设置为可见 &#125; puts(k);//直接输出&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1451 【求细胞数量】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-P1451-%E3%80%90%E6%B1%82%E7%BB%86%E8%83%9E%E6%95%B0%E9%87%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[怎么楼下都是bfs啊…… 忍不住来了一发dfs 其实dfs也挺快的啊，0ms呢…… 思路也很简单，搞一个数组，不为0的地方就是细胞，然后dfs搜连通块，把搜到的都归0，保证不重复。。。 然后就是循环找没被归0的，答案+1。 代码： 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;template &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123; int w=1;char c=0;x=0; while (c^'-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar(); if (c=='-')w=-1,c=getchar(); while (c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x*=w;&#125;inline void write(int n)&#123; if(n==0) return; write(n/10); putchar(n%10+'0');&#125;//输入输出优化，请自动忽略int n,m,ans,dx[]=&#123;-1,0,1,0&#125;,dy[]=&#123;0,-1,0,1&#125;,a[105][105];//a即地图，dx和dy方向增量数组就不用我讲了吧void dfs(int x,int y)&#123; if (x&gt;n||y&gt;m||x&lt;0||y&lt;0)return; a[x][y]=0;//标记为没有 for (int i=0;i&lt;4;i++)if (a[x+dx[i]][y+dy[i]])dfs(x+dx[i],y+dy[i]);//如果有才搜&#125;//搜索int main()&#123; read(n),read(m); for (int i=0;i&lt;n;i++) for (int j=0;j&lt;m;j++)scanf("%1d",&amp;a[i][j]);//只读1位 for (int i=0;i&lt;n;i++) for (int j=0;j&lt;m;j++)if (a[i][j])ans++,dfs(i,j);//找 write(ans);//输出 return 0;&#125; 好像挺简单的啊？]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3692 【夏幻的考试】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-P3692-%E3%80%90%E5%A4%8F%E5%B9%BB%E7%9A%84%E8%80%83%E8%AF%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题很简单啊，代码也没有必要写那么长 就是按题目说的模拟 代码： 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,ans[55];//ans[i]为第i题的正确序号（0，1，2，3）string s;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for (int i=0;i&lt;m;i++)ans[i]=s[i]-'A';//读入标准答案 while (n--)&#123; double cnt=0; int kh=0; cin&gt;&gt;s; for (int i=15;i&gt;=0;i--)kh+=(s[i]-'0')*pow(2,15-i);//算考号 bool khzq=kh&gt;=1&amp;&amp;kh&lt;=10000;//检查是否合法 if (!khzq)&#123; for (int i=0;i&lt;=m;i++)cin&gt;&gt;s; printf ("Wrong ID\n\n");continue;//不合法 &#125; cin&gt;&gt;s; if (s[0]==s[1])s[kh&amp;1]='0';//如果两个都填了或者两个都没填，让它变成错误 //不难发现考号%2就是最后一位，因为2的方冥都是偶的 printf ("ID: %d\nType %s\n",kh,s[kh&amp;1]-'0'?"Correct":"Incorrect");//输出ID和是否正确 for (int i=0;i&lt;m;i++)&#123; cin&gt;&gt;s; bool ok=0,f=0; for (int j=0;j&lt;4;j++)if (s[j]-'0'&amp;&amp;ok)f=1;//如果填了两个 else if (s[j]-'0')ok=1;//如果填了 if (ok&amp;&amp;!f&amp;&amp;s[ans[i]]-'0')cnt+=100.0/m;//只填了一个且填的是对的 &#125; printf ("%.1f\n\n",cnt);//输出 &#125; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF36A 【Extra-terrestrial Intelligence】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF36A-%E3%80%90Extra-terrestrial%20Intelligence%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题好坑啊…… 其实模拟并不难，但是输入和输出有坑： 输入要加freopen(“input.txt”,”r”,stdin) 输出要加freopen(“output.txt”,”w”,stdout)输入要加freopen(“input.txt”,”r”,stdin) 输出要加freopen(“output.txt”,”w”,stdout)输入要加freopen(“input.txt”,”r”,stdin) 输出要加freopen(“output.txt”,”w”,stdout)重要的事情说三遍 代码： 123456789101112131415#include&lt;cstdio&gt;int n,a[105],l1,l2;int main(void)&#123; freopen("input.txt","r",stdin); freopen("output.txt","w",stdout); scanf ("%d",&amp;n); for (int i=1;i&lt;=n;i++)&#123; scanf("%1d",&amp;a[i]); if(a[i]&amp;&amp;!l1)l1=i;//记录第一个1 else if (a[i]&amp;&amp;!l2)l2=i;//记录第2个1 &#125; for (int i=l2+1;i&lt;=n;i++)if (a[i]&amp;&amp;i-l2==l2-l1)l1=l2,l2=i;//间隔相同，更新 else if(a[i])return !printf ("NO");//不相同直接退出 printf ("YES");&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF228A 【Is your horseshoe on the other hoof?】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF228A-%E3%80%90Is%20your%20horseshoe%20on%20the%20other%20hoof%EF%BC%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题怎么没人做呢…… 其实看了我的翻译就知道是求4个数里有几个重复的-1 所以很简单了 代码很短就不写注释了 123456789#include &lt;bits/stdc++.h&gt;using namespace std;int a[4],ans;int main(void)&#123; scanf ("%d%d%d%d",&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3]); sort (a,a+4); for (int i=1;i&lt;4;i++)if (a[i]==a[i-1])ans++; printf ("%d",ans);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF977A 【Wrong Subtraction】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF977A-%E3%80%90Wrong%20Subtraction%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊怎么没人做？ 直接按题目说的模拟就行了。 代码： 1234567#include &lt;cstdio&gt;long long n,k;int main(void)&#123; scanf ("%d%d",&amp;n,&amp;k); while (k--)if (n%10)n--;else n/=10;//模拟 printf ("%lld",n);//输出&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF723A 【The New Year: Meeting Friends】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-CF723A-%E3%80%90The%20New%20Year%20Meeting%20Friends%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题非常简单，就是一个数论 首先，我们考虑最大和最小的两个数： 如果要他们的差最小，那么集合点必须在他们之间（绝对值的几何意义） 而这个点又可以设在中间值的点上，所以中间点的距离=0 所以此题的答案= $ max(a,b,c)-min(a,b,c)$ 代码： 12345678#include &lt;cstdio&gt;#define min(x,y) ((y)^(((x)^(y))&amp;(-((x)&lt;(y)))))#define max(x,y) ((x)^(((x)^(y))&amp;(-((x)&lt;(y)))))int main(void)&#123; int a,b,c; scanf ("%d%d%d",&amp;a,&amp;b,&amp;c); printf ("%d",max(max(a,b),c)-min(min(a,b),c));&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1740 【Diamond A&B(1)】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1740-%E3%80%90Diamond%20A%26B(1)%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题有毒。。。 貌似就我一个是用C++写过的…… 楼下已经说过题目什么意思，我这里就来说一下怎么实现 具体请看代码 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int n;string a[1777];int main(void)&#123; cin&gt;&gt;n; cout&lt;&lt;n&lt;&lt;endl; for (int i=0;i&lt;=n*2;i++)&#123; string s; getline(cin,s); a[i]=" "; a[i]+=s; &#125;//由于string读入时自动0下标，所以我要强制转成1下标 for (int i=1;i&lt;=2*n+1;i++,puts(""))&#123; int ps=n+!(i&amp;1),o=1+(i-1)/2,p=n+1-i/2;//ps是输出个数，o是起始行，p是起始列 for (int j=1;j&lt;=ps;j++)putchar(a[o++][p++]==' '?'0':'1');//模拟过去 &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2152 【[SDOI2009]SuperGCD】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P2152-%E3%80%90%5BSDOI2009%5DSuperGCD%E3%80%91%2F</url>
    <content type="text"><![CDATA[人生中第一篇$ \color{purple} \text{紫题} $的题解 其实不得不指出楼下的一个错误： 使用py3写辗转相除法并不会RE！！！ 甚至连函数都不用，只要一个循环就好。 代码： 1234567a=int(input())b=int(input())while b&gt;0: c=b//先记下b b=a%b//改掉b a=c//改掉aprint(a)]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1865 【A % B Problem】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1865-%E3%80%90A%20%25%20B%20Problem%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题大家应该都能看出来要用筛法+前缀和吧……所以我觉得这题顶多普及- 所以我来讲两个优化： 1. 其实前缀和并不用再开一个数组2. 前缀和其实并不是非要套在循环里绕，完了再特判，只需要再开一个循环就可以了具体看代码： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;int n,m,l,r,a[1000000];void prime()&#123; for (int i=2;i&lt;=m;i++)if (!a[i]) for (int j=i*2;j&lt;=m;j+=i)a[j]=1;//标准线筛 for (int i=2;i&lt;=m;i++)a[i]=!a[i],a[i]+=a[i-1];//处理前缀和：直接在同一个数组里处理，a[i]=!a[i]是把原来对质数的标记0改成1，对合数的标记1改成0，然后就可以放心地加上前面的了&#125;template &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123; int w=1;char c=0;x=0; while (c^'-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar(); if (c=='-')w=-1,c=getchar(); while (c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x*=w;&#125;inline void write(int n)&#123; if(n==0) return; write(n/10); putchar(n%10+'0');&#125;int main()&#123; read(n),read(m); prime(); while (n--)&#123; read(l),read(r); if (l&lt;1||l&gt;m||r&lt;1||r&gt;m)&#123;puts("Crossing the line");continue;&#125; if (a[r]-a[l-1])write(a[r]-a[l-1]);//标准前缀和输出方式 else putchar('0');puts(""); &#125;&#125;//至于某些多打的部分是快读+快输，个人喜好。]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4711 【「化学」相对分子质量】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4711-%E3%80%90%E3%80%8C%E5%8C%96%E5%AD%A6%E3%80%8D%E7%9B%B8%E5%AF%B9%E5%88%86%E5%AD%90%E8%B4%A8%E9%87%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[恩这题其实并没有那么难，根本没有必要搞什么单调栈什么的，所以我来一发很短的题解。 本题的思路就是逐个击破，我的思路是这样的： 1.元素对于单个元素的处理应该是很简单的，因为我们有强大的map，一个表就结束了。 2.下标这里我主要分两种情况看： 对原子的下标 只需要保存每个元素的值（last），如果发现下标就把已经加到ans里的last减掉，重新加上last×下标系数就可以了。 对原子团的下标 这个等会会在原子团的部分里解释 3.原子团这个对于原子团中可能出现的嵌套问题，我选择了递归解决 原子团中的原子跟原子团外的原子是一个解决方法（原子+下标） 然后接下来就是原子团的下标了 这个问题需要我们对原子团中的运算结果进行一个tmp的保存，然后在退出函数之前检查外面有没有下标，有的话立即解决。 4.水合物这个就很简单了，检测到~后直接计算系数，然后乘以18（H_{2}O的值）就可以了 具体的一些坑点会在代码里说 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;double ans,last;//小心别手残打成int了（因为有.5的存在）string a;map &lt;string,double&gt; mp;//一个map其实可以帮我们很多忙inline void start()&#123;mp["H"]=1;mp["C"]=12;mp["N"]=14;mp["O"]=16;mp["F"]=19;mp["Na"]=23;mp["Mg"]=24;mp["Al"]=27;mp["Si"]=28;mp["P"]=31;mp["S"]=32;mp["Cl"]=35.5;mp["K"]=39;mp["Ca"]=40;mp["Mn"]=55;mp["Fe"]=56;mp["Cu"]=64;mp["Zn"]=65;mp["Ag"]=108;mp["I"]=127;mp["Ba"]=137;mp["Hf"]=178.5;mp["Pt"]=195;mp["Au"]=197;mp["Hg"]=201;&#125;//打表int ys(int k)&#123; string s="";int j=k+1;s+=a[k]; for (;a[j]&gt;='a'&amp;&amp;a[j]&lt;='z';j++)s+=a[j]; ans+=last=mp[s];//存下上一个值，为下标作准备 return j;&#125;//对单个元素处理：用string提取单个元素，然后直接拿mp映射表搞int xb(int k)&#123; int j=k+2,s=0; for (;a[j]&gt;='0'&amp;&amp;a[j]&lt;='9';j++)s=s*10+a[j]-'0'; ans-=last,ans+=last*s; return j;&#125;//外部下标double tmp,tlast;//tmp为括号里的运算结果，tlast为括号里的上一个值int xbk(int k)&#123; int j=k+2,s=0; for (;a[j]&gt;='0'&amp;&amp;a[j]&lt;='9';j++)s=s*10+a[j]-'0'; tmp-=tlast,tmp+=tlast*s; return j;&#125;//括号里的下标int ysk(int k)&#123; string s="";int j=k+1;s+=a[k]; for (;a[j]&gt;='a'&amp;&amp;a[j]&lt;='z';j++)s+=a[j]; tmp+=tlast=mp[s]; return j;&#125;//括号里的元素inline int kh(int k)&#123; int j=k+1,h=1;//h表示当前未匹配的左括号数 while (h!=0)&#123; if (a[j]==')')h--;//匹配到一个 if (!h)break; if (a[j]&gt;='A'&amp;&amp;a[j]&lt;='Z')&#123; j=ysk(j); if (a[j]=='_')j=xbk(j)+1; &#125;else if (a[j]=='(')h++,j=kh(j);//又出来一个，递归 &#125; if (a[j+1]=='_')ans+=tmp,last=tmp,j=xb(j+1);//原子团的下标 tmp=0;//记得归0 return j;&#125;//括号void sh(int k)&#123; int j=k+1,f=0; for (;a[j]&gt;='0'&amp;&amp;a[j]&lt;='9';j++)f=f*10+a[j]-'0'; if (!f)f++;//注意！！！如果f没提取到说明省略了系数，千万别忘了默认为1！ ans+=f*18;&#125;//水合物int main()&#123; start(); cin&gt;&gt;a; for (int i=0;i&lt;a.size();i++)&#123; if (a[i]&gt;='A'&amp;&amp;a[i]&lt;='Z')i=ys(i)-1; else if (a[i]=='_')i=xb(i); else if (a[i]=='(')i=kh(i); else if (a[i]=='~')&#123;sh(i);break;&#125; &#125; printf ("%g",ans);//%g的输出可以省掉多余的0 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2682 【土豆田】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P2682-%E3%80%90%E5%9C%9F%E8%B1%86%E7%94%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[经过看楼下的题解我也AC了 AC记录：AC 此题每问的做法楼下都已经讲过了，我就来一发具体的代码+写代码的技巧 此题有一个坑点就是必须控制程序的运行次数，然而很多都不好卡。（比方说#2测试点我就卡了好久） 以#2为例，将a*233分解为： $$ a*233=a*128+a*64+a*32+a*8+a $$ 如果用一个土豆，好像没办法卡进9cycles. 那么怎么办呢？ 我就把 $ a*128+a $分配给1号土豆，然后再负责加上2号土豆算的 $ a*64+a*32 $，把结果传回给2号土豆，2号土豆并负责加上3号土豆算的 $ a*8 $，最后的结果由4号土豆汇总并输出。 答案：我等急死了 答案： 1.点击展开/收起 1234567891011121 23inswapopp5inswapget ladd tmpout 2.点击展开/收起 123456789101112131415161718192021222324252627282930313233342 26inadd tmpL 7add tmpget radd tmp7waitget ladd tmpL 6R 1get ladd tmp4waitget uswapL 39waitwaitwaitget ladd tmpwaitget uadd tmpout 3.点击展开/收起 1234567891 17inadd tmpR 31swapadd tmpxor tmpout 4.点击展开/收起 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862874 232inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmp34inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpget ladd tmp32inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmp36inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpget ladd tmpget uadd tmp32inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmp39inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpget ladd tmpget dadd tmpget uadd tmpout32inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmp34inadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpinadd tmpget ladd tmp 这打表一样的代码 5.点击展开/收起 123456789101112131415161 25inswapget rxor tmpR 17inswapget land tmpget ladd tmpout 不知为何下面的一段代码不对： 点击展开/收起 123456781 16inswapinadd tmpR 1out 知道的可以私信告诉我QAQ 6.点击展开/收起 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471 223inadd tmpR 1and 1431655765get radd tmpR 2and 858993459get radd tmpR 4and 252645135get radd tmpR 8and 16711935get radd tmpR 16and 65535get radd tmpout20waitget ladd tmpand 1431655765waitget lswapand 858993459waitget lswapand 252645135waitget lswapand 16711935waitget lswapand 65535 原本的C++代码是这个： 点击展开/收起 12345678910111213141516#include &lt;cstdio&gt;int func(unsigned int i)&#123; unsigned int temp = i; temp = (temp &amp; 0x55555555) + ((temp&gt;&gt; 1) &amp; 0x55555555); //temp相邻位相加 temp = (temp &amp; 0x33333333) + ((temp &gt;&gt; 2) &amp; 0x33333333); //temp相邻（以2为单位）相加 temp = (temp &amp; 0x0f0f0f0f) + ((temp&gt;&gt; 4) &amp; 0x0f0f0f0f); //temp相邻（以4为单位）相加 temp = (temp &amp; 0xff00ff) + ((temp&gt;&gt; 8) &amp; 0xff00ff); //temp相邻（以8为单位）相加 temp = (temp &amp; 0xffff) + ((temp&gt;&gt; 16) &amp; 0xffff) ; //temp相邻（以16为单位）相加 return temp;&#125;int main(void)&#123; int a; scanf ("%d",&amp;a); printf ("%d",func(a));&#125; 我纯人工把改写了23行（流泪） 这打表一样的代码*2，怪不得被楼下和谐了 7.点击展开/收起 123451 13inswapout 肮脏的我为了不动脑子，果断地利用了SPJ的bug 8.点击展开/收起 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552561 1254inset tmpadd -1if keygoto 9set 1outendadd -1if keygoto 15set 2outendadd -1if keygoto 21set 3outendadd -1if keygoto 27set 5outendadd -1if keygoto 33set 8outendadd -1if keygoto 39set 13outendadd -1if keygoto 45set 21outendadd -1if keygoto 51set 34outendadd -1if keygoto 57set 55outendadd -1if keygoto 63set 89outendadd -1if keygoto 69set 144outendadd -1if keygoto 75set 233outendadd -1if keygoto 81set 377outendadd -1if keygoto 87set 610outendadd -1if keygoto 93set 987outendadd -1if keygoto 99set 1597outendadd -1if keygoto 105set 2584outendadd -1if keygoto 111set 4181outendadd -1if keygoto 117set 6765outendadd -1if keygoto 123set 10946outendadd -1if keygoto 129set 17711outendadd -1if keygoto 135set 28657outendadd -1if keygoto 141set 46368outendadd -1if keygoto 147set 75025outendadd -1if keygoto 153set 121393outendadd -1if keygoto 159set 196418outendadd -1if keygoto 165set 317811outendadd -1if keygoto 171set 514229outendadd -1if keygoto 177set 832040outendadd -1if keygoto 183set 1346269outendadd -1if keygoto 189set 2178309outendadd -1if keygoto 195set 3524578outendadd -1if keygoto 201set 5702887outendadd -1if keygoto 207set 9227465outendadd -1if keygoto 213set 14930352outendadd -1if keygoto 219set 24157817outendadd -1if keygoto 225set 39088169outendadd -1if keygoto 231set 63245986outendadd -1if keygoto 237set 102334155outendadd -1if keygoto 243set 165580141outendadd -1if keygoto 249set 267914296outendadd -1if keygoto 255set 433494437outend 老师说过goto不好不要乱用，然而还是看到了这不和谐的代码 我的第一份黑题题解，大家谅解一下自认为高清无码的标准答案还是大家喜闻乐见的]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1721 【[NOI2016]国王饮水记】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1721-%E3%80%90%5BNOI2016%5D%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题根本不用那么麻烦，一个贪心即可。 贪心策略也很简单，就是原则1：能连2个不连3个 为什么呢？我们举例验证。 例：$n=3,h1=1,h2=1.7,h3=3$ 这时，如果连通1、2、3，水位为$ \frac{1+1.7+3}{3}=1.9 $，而如果连通1、3，水位为$ \frac{1+3}{2}=2$，这时，由于2的水位低于平均数，所以2反而拖了后腿。 有没有办法利用2呢？ 有。 如果先连通1、2，水位为$\frac{1+1.7}{2}=1.35 $，再连通1、3，水位为$\frac{1.35+3}{2}=2.175$，比刚才高。 所以得到一个推论：原则2：如果要加入一个城市进入连通器，它的水位一定要比已有平均数高 在一般情况下，尽量一次连2个；如果k不够用，则用原则2，将2次的连通并为一次。 接下来就是难点：恶心毒瘤的保留p位小数的高精除。$ \color{black} \colorbox{black}{所以根本不用写700行代码啊？} $ 最优解的代码：（为了好看我改了一点） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;int N,n,m,p;int h[8192],s[8192];//8192=2&lt;&lt;13double f[16][8192];int g[16][8192];int a[400];using namespace std;#define P pair&lt;int,double&gt;double operator%(const P&amp;a,const P&amp;b)&#123; return (b.second-a.second)/(b.first-a.first);&#125;//重载运算符void div(int x)&#123; long long q=0; for(int i=0;i&lt;=p;i++)&#123; q=q*1000000000+a[i];a[i]=q/x;q%=x; &#125;&#125;//恶心的除，用重载运算符实现int main()&#123; scanf("%d%d%d",&amp;N,&amp;m,&amp;p);p=p/9+1; scanf("%d",&amp;h[n=1]); for(int i=2;i&lt;=N;i++)&#123; int t;scanf("%d",&amp;t);if(h[1]&lt;t)h[++n]=t; &#125; sort(h+1,h+n+1); if(m&gt;n)m=n; for(int i=1;i&lt;=n;i++)f[0][i]=h[1],s[i]=s[i-1]+h[i];//前缀和 int l=14;if(l&gt;m)l=m; for(int i=1;i&lt;=l;i++)&#123; static P q[8024]; for(int j=2,l=1,r=0;j&lt;=n;j++)&#123; P c=P(j-2,s[j-1]-f[i-1][j-1]); for(;l&lt;r&amp;&amp;(q[r-1]%q[r])&gt;(q[r]%c);r--); q[++r]=c; P t=P(j,s[j]); for(;l&lt;r&amp;&amp;(q[l]%t)&lt;(q[l+1]%t);l++); g[i][j]=q[l].first+1; f[i][j]=(q[l]%t); &#125; &#125; int _[16];_[l]=n-(m-l); for(int i=l;i;i--)_[i-1]=g[i][_[i]]; a[0]=h[1]; for(int i=1;i&lt;=l;i++)a[0]+=s[_[i]]-s[_[i-1]],div(_[i]-_[i-1]+1); for(int i=_[l]+1;i&lt;=n;i++)a[0]+=h[i],div(2);//以上为贪心 printf("%d.",a[0]); for(int i=1;i&lt;=p;i++)printf("%09d",a[i]);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1983 【车站分级】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1983-%E3%80%90%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7%E3%80%91%2F</url>
    <content type="text"><![CDATA[我来这里发题解只是为了证明：某种被认为是非正解的算法，其实是可以AC的！ 先看：https://www.luogu.org/blog/user56917/solution-p1983 其实，我并没有改动多少，只是进行了几个很常用的优化： 避免重复定义变量 在原来的代码中，有一段是这样的： 12for(register int iii=1;iii&lt;=m;iii++)&#123; int cnt=get(); 在这一段中，cnt被反复定义了$ m $次，导致了时间的浪费，因为这明明是一个可以一次解决的问题。 少写头文件 你写的头文件中的函数每调用一次，编译器就载入一次，所以记住这个原则： $ \text{函数能手打就手打，头文件能不调用就不调用} $ 所以我省去了iostream头文件，没用using namespace std;，而是手写了max：#define max(x,y) ((x)^(((x)^(y))&amp;(-((x)&lt;(y))))) 不用cin/cout cin/cout其实很慢的，如果你被卡常了，记得换成快读/快输 经过这几个优化，就可以AC了，第8个点只用了832ms。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#define max(x,y) ((x)^(((x)^(y))&amp;(-((x)&lt;(y))))) //手写maxtemplate &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123; int w=1;char c=0;x=0; while (c^'-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar(); if (c=='-')w=-1,c=getchar(); while (c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x*=w;&#125;inline void write(int n)&#123; if(n==0) return; write(n/10); putchar(n%10+'0');&#125;//快读/快输int que[100000000],dis[2011],v[1011][1011],ints[10000],qian[1011][1011],n,m,ans,cnt;//变量尽量一次定义unsigned char bv[2011],G[1011][1011],st[2011];inline void add(int s,int t,int l)&#123; G[s][t]=1; v[s][t]=max(v[s][t],l);&#125;int main()&#123; read(n),read(m); for(register int iii=1;iii&lt;=m;iii++)&#123; read(cnt); memset(bv,0,sizeof(bv)); for(register int i=1;i&lt;=cnt;i++)read(ints[i]),bv[ints[i]]=1; for(register int i=1;i&lt;=cnt;i++) for(register int j=ints[1];j&lt;=ints[cnt];j++)if(!bv[j])add(j,ints[i],1); &#125;//register定义变量很快的 memset(bv,0,sizeof(bv)); for(register int i=1;i&lt;=n+1;i++)dis[i]=-1234567890; register int head=0,tail=1;que[0]=n+1; dis[n+1]=0; for(register int i=1;i&lt;=n;i++)add(n+1,i,1); for(register int i=1;i&lt;=n+1;i++) for(register int j=1;j&lt;=n+1;j++) if(i!=j&amp;&amp;G[i][j])qian[i][0]++,qian[i][qian[i][0]]=j; do&#123; int me=que[head];head++;bv[me]=0; for(register int j=1;j&lt;=qian[me][0];j++)&#123; int i=qian[me][j]; if(dis[me]+v[me][i]&gt;dis[i])&#123; dis[i]=dis[me]+v[me][i]; if(!bv[i])bv[i]=1,que[tail++]=i; &#125; &#125; &#125;while(head&lt;tail); for(register int i=1;i&lt;=n;i++)st[dis[i]]=1; for(register int i=1;i&lt;=1000;i++)ans+=st[i]; write(ans); return(0);&#125; 原解法：这篇文章摆在一起]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4212 【外太空旅行】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4212-%E3%80%90%E5%A4%96%E5%A4%AA%E7%A9%BA%E6%97%85%E8%A1%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目其实是bitset的一个很好的应用，再结合一下楼下的随机数算法即可AC。 注意一下，由于两个人之间要么是朋友要么是敌人，那么我们可以考虑将两个人之间的关系改为2进制。这就是bitset的原理。 bitset很强大，可以对很多数据类型进行转换，重点是：支持运算操作！ 那么这题的做法就很显然了：直接用一个bitset now 来维护当前顺序可以入选的名单（用 &amp; 运算可以模拟水火不容 or 基♂情满满） 剩下来的就是用随机生成顺序来取最大值了，最后存答案的bitset ans 的数量（ $ ans.count() $ 就是答案）。（ans中1的个数即表示有多少人能和睦相处） 代码就不贴了，只有18行，相信大家都能打出来。]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4907 【A换B problem】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4907-%E3%80%90A%E6%8D%A2B%20problem%E3%80%91%2F</url>
    <content type="text"><![CDATA[出题人来写一发题解 此题主要就是搜索，为了提升难度，我还搞了一个恶心的读入 接下来就是搜索了。 具体码里说吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;bits/stdc++.h&gt;using namespace std;bool a[5][14];int ans,p,k,n,i,ant;char ch;string st;bool bb;bool check() &#123; int i,j,t; bool b; for (j=1; j&lt;=4; j++) &#123; t=0; b=false; for (i=1; i&lt;=k; i++)if (a[j][i])t++; i=0; if (t==1||t==13)continue; while (i&lt;k) &#123; i++; if (t==0)break; if (a[j][i]) &#123; t--; if (b) continue; else b=true; &#125; else if (b)return false; else continue; &#125; &#125; return true;&#125;//判断是否连续（即换完后是否可行）void check2() &#123; int i,j,t,y; bool b; y=0; for (j=1; j&lt;=4; j++) &#123; t=0; for (i=1; i&lt;=k; i++)if (a[j][i])t++; i=0; if (t==0||t==13||t==1) continue; b=false; while (i&lt;k) &#123; i++; if (t==0) break; if (a[j][i]) &#123; t--; if (b) continue; else b=true; &#125; else if (b)y++; else continue; &#125; &#125; if (y&lt;ant) ant=y;&#125;//同上，另一个判断void search(int q,int b) &#123; int i,j,o,y[5],w[5]; if (q==k+1) &#123; if (check()) &#123; bb=true; if (ans&gt;b) ans=b; &#125; if (!bb) check2(); return ; &#125; search(q+1,b); j=0; for (i=1; i&lt;=4; i++) if (a[i][q]) &#123; j++; y[j]=i; &#125; else &#123; w[i-j]=i; &#125; if (j==4||j==0)return ; if (j==1||j==3) &#123; if (j==3) &#123; for (o=1; o&lt;=3; o++) &#123; if (a[i][j+1]&amp;&amp;a[i][j-1])continue; if (!(a[o][j+1]||a[o][j-1]))continue; a[w[1]][q]=true; a[y[o]][q]=false; search(q+1,b+1); a[w[1]][q]=false; a[y[o]][q]=true; &#125; &#125; if (j==1) &#123; for (o=1; o&lt;=3; o++) &#123; if (a[i][j+1]&amp;&amp;a[i][j-1])continue; //if (!(a[o][j+1]||a[o][j-1]))continue; a[w[o]][q]=true; a[y[1]][q]=false; search(q+1,b+1); a[w[o]][q]=false; a[y[1]][q]=true; &#125; &#125; &#125; else &#123; for (o=1; o&lt;=2; o++) &#123; if (a[i][j+1]&amp;&amp;a[i][j-1])continue; if (!(a[o][j+1]||a[o][j-1]))continue; a[w[o]][q]=true; a[y[1]][q]=false; search(q+1,b+1); a[w[o]][q]=false; a[y[1]][q]=true; a[w[o]][q]=true; if (a[i][j+1]&amp;&amp;a[i][j-1])continue; if (!(a[o][j+1]||a[o][j-1]))continue; a[y[2]][q]=false; search(q+1,b+1); a[w[o]][q]=false; a[y[2]][q]=true; &#125; a[w[1]][q]=true; a[y[1]][q]=false; a[w[2]][q]=true; a[y[2]][q]=false; search(q+1,b+2); a[w[1]][q]=false; a[y[1]][q]=true; a[w[2]][q]=false; a[y[2]][q]=true; &#125;&#125;//搜索，具体过程就是分类讨论，对每个牌的编号+1、-1进行搜索int main() &#123; cin&gt;&gt;n; for (i=1; i&lt;=n; i++) &#123; cin&gt;&gt;p&gt;&gt;st; if (st=="A") &#123; a[p][1]=true; if (1&gt;k)k=1; &#125; if (st=="2") &#123; a[p][2]=true; if (2&gt;k)k=2; &#125; if (st=="3") &#123; a[p][3]=true; if (3&gt;k)k=3; &#125; if (st=="4") &#123; a[p][4]=true; if (4&gt;k)k=4; &#125; if (st=="5") &#123; a[p][5]=true; if (5&gt;k)k=5; &#125; if (st=="6") &#123; a[p][6]=true; if (6&gt;k)k=6; &#125; if (st=="7") &#123; a[p][7]=true; if (7&gt;k)k=7; &#125; if (st=="8") &#123; a[p][8]=true; if (8&gt;k)k=8; &#125; if (st=="9") &#123; a[p][9]=true; if (9&gt;k)k=9; &#125; if (st=="10") &#123; a[p][10]=true; if (10&gt;k)k=10; &#125; if (st=="J") &#123; a[p][11]=true; if (11&gt;k)k=11; &#125; if (st=="Q") &#123; a[p][12]=true; if (12&gt;k)k=12; &#125; if (st=="K") &#123; a[p][13]=true; if (13&gt;k)k=13; &#125;//鬼畜的读入 &#125; ans=255; ant=255; search(1,0); if (bb) &#123; puts("Yes"); printf ("%d\n",ans); &#125; else &#123; puts("No"); printf ("%d\n",ant); &#125;//输出&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5003 【跳舞的线 - 乱拐弯】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P5003-%E3%80%90%E8%B7%B3%E8%88%9E%E7%9A%84%E7%BA%BF-%E4%B9%B1%E6%8B%90%E5%BC%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题完全没有楼下讲的那么难……我就来解释一下我的思路吧 首先，(i,j)这个点的答案肯定由(i-1,j)和(i,j-1)的答案确定（因为只准往下、往右走） 我设到达(i,j)时的最大拐弯数为f[i][j]，则有 f[1][1…n]=0 f[1…n][1]=0 我用h[i][j]表示到(i,j)的走向（0表示向右，1表示向下，2表示任意） 则可以得到转移： $f[i][j]=max(f[i-1][j]+(h[i-1][j]!=1),f[i][j-1]+(h[i-1][j]!=0))$ 为什么用!=而不用==呢？因为是求最大拐弯数，所以能拐我一定拐，!=保证了当上一个点只要不是当前方向就一定拐。 这也是h数组中2的用处。 因为不仅要答案，还要求h数组，所以这个max我是用if分类讨论实现的 同理可得，$g[i][j]=min(g[i-1][j]+(k[i-1][j]==0),g[i][j-1]+(k[i][j-1]==1))$，这里的==保证了能不拐我绝对不拐 然后就是一个坑：要先跑一遍，看能不能到。 最后初始化：$f[2…n][2…m]=-(1&lt;&lt;11),g[2…][2…m]=1&lt;&lt;11,h[1…n][1]=1 \text{因为向下走只有1种可能}$ 具体细节看代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,f[1005][1005],g[1005][1005],h[1005][1005],k[1005][1005];char c;bool v[1005][1005],can[1005][1005];int check(int i,int j)&#123; if (can[i-1][j]&amp;&amp;can[i][j-1])return 2; else if (can[i-1][j])return 1; else return 0;&#125;//在分类讨论中，判断当从(i-1,j)和(i,j-1)过来且拐弯数相同时哪一种可行int main()&#123; cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;c; if (c=='#')v[i][j]=1,can[i][j]=0;//标记为不可走 &#125; can[1][1]=!v[1][1]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; can[i][j]|=can[i-1][j]|can[i][j-1]; if (v[i][j])can[i][j]=0; &#125; if (!can[n][m])return !printf ("-1");//看能不能过 for (int i=2;i&lt;=n;i++) for (int j=2;j&lt;=m;j++)f[i][j]=-(1&lt;&lt;11),g[i][j]=1&lt;&lt;11;//初始化 for (int i=1;i&lt;=n;i++)h[i][1]=k[i][1]=1; for (int i=2;i&lt;=n;i++) for (int j=2;j&lt;=m;j++)if (can[i][j])&#123; if (f[i-1][j]+(h[i-1][j]!=1)&gt;f[i][j-1]+(h[i][j-1]!=0)&amp;&amp;(can[i-1][j]))f[i][j]=f[i-1][j]+(h[i-1][j]!=1),h[i][j]=1;//从(i-1,j)过来可行且更优 else if (f[i-1][j]+(h[i-1][j]!=1)==f[i][j-1]+(h[i][j-1]!=0))f[i][j]=f[i-1][j]+(h[i-1][j]!=1),h[i][j]=check(i,j);//相同 else if (can[i][j-1])f[i][j]=f[i][j-1]+(h[i][j-1]!=0),h[i][j]=0;//(i,j-1)更优 if (g[i-1][j]+(k[i-1][j]==0)&lt;g[i][j-1]+(k[i][j-1]==1)&amp;&amp;(can[i-1][j]))g[i][j]=g[i-1][j]+(k[i-1][j]==0),k[i][j]=1; else if (g[i-1][j]+(k[i-1][j]==0)==g[i][j-1]+(k[i][j-1]==1))g[i][j]=g[i-1][j]+(k[i-1][j]==0),k[i][j]=check(i,j); else if (can[i][j-1])g[i][j]=g[i][j-1]+(k[i][j-1]==1),k[i][j]=0;//同上 &#125; if (f[n][m]&gt;0)printf ("%d %d\n",f[n][m],g[n][m]); else putchar('-'),putchar('1');&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3386 【【模板】二分图匹配】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P3386-%E3%80%90%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E3%80%91%2F</url>
    <content type="text"><![CDATA[考前发个题解涨涨RP 感谢@nederland 巨佬提供了一个网络最大流+邻接矩阵的解法，我就在这里提一下如何优化 原解法：https://www.luogu.org/recordnew/lists?uid=nederland&amp;pid=P3386&amp;status=14&amp;sort=0 可以看到，除第一个AC以外，剩下来的T死…… 那么，如何优化呢？ 1. 快读+快输！这个东西，大家都知道，我就不解释了 2. O(3)虽说NOIP不给用，然而在此题中还是很有用的 3. register这是一个C++保留字，用来将变量存入内存，加速。 4. 避免变量重复定义这个东西有效优化时间。比方说一个1000000的循环，你定义一个变量，定义1000000次，不T都怪。相比之下，虽然仍然需要赋值，但减少了重复定义的时间。 用了这些，此题就可以A了啊…… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#pragma GCC optimize(3)#define min(x,y) ((y)^(((x)^(y))&amp;(-((x)&lt;(y)))))bool vis[2005];int pred[2005],cap[2005][2005],flow[2005][2005],N,t;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;template &lt;typename _Tp&gt;inline void read(_Tp &amp;x)&#123; int f=1;x=0;char ch=nc(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=nc();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=nc();&#125; x*=f;&#125;inline void write(long long n)&#123; if(n==0) return; write(n/10); putchar(n%10+'0');&#125;//快读+快输……然而printf比快输还快（我写炸了？）int findpath(int u,int x)&#123; if(u==t)return x; vis[u]=true; for(int v=0;v&lt;N;v++)&#123; if(!vis[v])&#123; int dt=cap[u][v]-flow[u][v]; if(dt&gt;0)&#123; pred[v]=u; int r=findpath(v,min(x,dt)); if(r)return r; &#125; &#125; &#125; return 0;&#125;int main()&#123; register int n,m,s,e,r,v,i,u;//优化3、4 read(n),read(m),read(e);//优化1 s=0;t=n+m+1;N=n+m+2; for(i=1;i&lt;=n;i++)cap[s][i]=1; for(i=1;i&lt;=m;i++)cap[n+i][t]=1; for(i=0;i&lt;e;i++)&#123; read(u),read(v);//优化1 if(u&gt;n||v&gt;m)continue; cap[u][v+n]=1; &#125; while(true)&#123; for(i=0;i&lt;N;i++)vis[i]=false; r=findpath(s,999999999); if(!r)break; v=t; while(v!=s)&#123; u=pred[v]; flow[u][v]+=r; flow[v][u]-=r; v=u; &#125; &#125; register int sum=0; for(i=0;i&lt;N;i++)sum+=flow[s][i]; printf("%d",sum); return 0;&#125; 由@nederland 巨佬的代码优化而来]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5019 【铺设道路】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P5019-%E3%80%90%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目就我一个人模拟吗？ 普及蒟蒻，不会好算法，就来说一发模拟吧 首先一个贪心： 每次选一个连续正深度的坑的区间去填为什么呢？因为只有这样，才能保证我每次填坑的数量最多，不会造成浪费（即可以一天解决的问题我2天解决），也就是保证填的天数最少 于是得到了$ O(n^2* sum(a[1…n])) $，嗯，超时成什么样我就不说了 于是优化： 观察下面的表： d[1] d[2] d[3] d[4] d[5] d[6] d[7] 1 4 3 3 4 3 3 0 3 2 2 3 2 2 0 2 1 1 2 1 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 可以发现，第2行与第3行实际上是重复的 在本例中，只重了2行； 如果重个10000，100000行呢？ 那么你的程序就会T。 如何优化？ 不难发现，我们填坑的过程是有规律的； 于是就有了优化： 每次循环必然要彻底填掉至少1个坑 那么，实现就很简单了： 在找连续整数的时候，顺便查找最小值，然后区间减最小值，完成目标。 到此为止，你已经拿到80分了 还有两个点什么情况？ 因为，尽管我们优化了，整个复杂度还是$ O(n^{2}) $，是会T的 再优化！ 我们可以发现，当我们找区间的开始的时候，其实是有单调性的 即：我下一次填坑的起始点一定在本次填坑的范围中那么在模拟减的时候就可以顺便找下一次的开始了。 你也许发现了一个问题： 一遍坑全部填平了怎么办？ 没事，设定一个极值，最后判一下，如果没变的话就从本次的结束点往后找啦~ 于是复杂度降到了$ O(n+\text{常数}) $，就AC了 代码： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int n,d[100005],q=1;long long s,ans;int main()&#123; scanf ("%d",&amp;n); for (int i=1;i&lt;=n;i++)scanf ("%d",&amp;d[i]),s+=d[i];//读入，统计和 int b=1; while (d[b]==0)b++;//找开端 q=b;//下一个开端 while (s)&#123; b=q; int e=b,mn=1&lt;&lt;20; while (d[e])mn=min(mn,d[e]),e++;//找最小值 ans+=mn,s-=mn*(e-b);//花mn天干，总和减去填的所有 q=1&lt;&lt;20; for (int i=e-1;i&gt;=b;i--)&#123;d[i]-=mn;if (d[i]&gt;0)q=i;&#125;//模拟减，同时找下一次的开端 if (q==1&lt;&lt;20)for (q=e+1;q&lt;=n;q++)if(d[q]&gt;0)break; &#125; printf ("%d",ans);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4432 【[COCI2017-2018#2] ZigZag】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4432-%E3%80%90%5BCOCI2017-2018%232%5D%20ZigZag%E3%80%91%2F</url>
    <content type="text"><![CDATA[没有C++题解？我来一发 这题目实际上可以用C++vector轻松解决 具体代码里说吧 123456789101112131415161718192021222324252627282930313233343536// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;#include &lt;vector&gt;using namespace std;int n,k,q[30];//q为以a开头的单词中应该选的序号vector &lt;string&gt; a[30];//建立一个以首字母序号为索引的vectorchar c;int main()&#123; scanf("%d%d",&amp;k,&amp;n); while(k--)&#123; string s; cin&gt;&gt;s; a[s[0]-'a'].push_back(s);//vector的基本用法 &#125; for (int i=0;i&lt;26;i++)sort(a[i].begin(),a[i].end());//C++对string的排序默认按字典序 while (n--)&#123; cin&gt;&gt;c; cout&lt;&lt;a[c-'a'][q[c-'a']]&lt;&lt;endl; q[c-'a']=(q[c-'a']+1)%a[c-'a'].size();//+1指向下一个，同时取模 //经观察可发现： //单词：zadar zoo //次数：0 0 //第一次选zadar： // zadar zoo // 1 0 //则第二次选zoo： // zadar zoo // 1 1 //第三次又选zadar： // zadar zoo // 2 1 //… //则可以发现：无论有多少次，在同一字母开头的单词中下标一直单调递增 //所以直接+1就可以啦。 &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1918 【保龄球】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1918-%E3%80%90%E4%BF%9D%E9%BE%84%E7%90%83%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题竟然没有C++set的，STL会伤心的QAQ 我先讲一下本题的暴力做法 不解释，读入n个数据，然后对于每个m查找。 代码： 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,a[100005],q;int main()&#123; scanf ("%d",&amp;n); for (int i=1;i&lt;=n;i++)scanf ("%d",&amp;a[i]); scanf ("%d",&amp;q); while (q--)&#123; bool ok=0; scanf ("%d",&amp;m); for (int i=1;i&lt;=n&amp;&amp;!ok;i++)if (a[i]==m)ok=printf ("%d\n",i); if (!ok)printf ("0\n"); &#125;&#125; 非常简单，于是快乐的T了。 观察一下，T的效率瓶颈在于 1for (int i=1;i&lt;=n&amp;&amp;!ok;i++)if (a[i]==m)ok=printf ("%d\n",i); 这里是朴素的查找，最坏会退化到O(n)的级别 那么如何优化呢？ 此处分出了2条思路： 1.用map搞映射这玩意相当于开了一个非常大的桶，而且也有题解讲了，我就不多说了 2.用STL的lower_bound首先讲一下为什么用lower_bound。 因为lower_bound是找第一个≥n的元素，所以如果在数组中有n的话一定会找到n。 然后又分出了2条思路： 用结构体重载运算符 这个也有题解介绍了，我就不说了 用set 大家都知道，set按第一关键字排序，所以我们可以用结构体的思想，用set维护一个二元组(s,id)，s为具体值，id为行号。接下来就可以愉快地用lower_bound啦~ 代码： 123456789101112131415161718192021// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;pair&lt;int,int&gt; &gt; st;//新建一个setint n,m,q,s;int main()&#123; ios::sync_with_stdio(false); cin.tie(0),cout.tie(0);//加速流读入 cin&gt;&gt;n; for (register int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s; st.insert(make_pair(s,i));//插入二元组 &#125; cin&gt;&gt;q; while (q--)&#123; cin&gt;&gt;m; set&lt;pair&lt;int,int&gt; &gt;::iterator it=st.lower_bound(make_pair(m,0)); if (it-&gt;first==m)cout&lt;&lt;(it-&gt;second)&lt;&lt;endl;//如果能找到m，输出id； else cout&lt;&lt;0&lt;&lt;endl;//找不到输出0 &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF479A 【Expression】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-CF479A-%E3%80%90Expression%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目就是个水题 思路楼下P党的题解已经说的很清楚了 我就来一发C++的代码 1234567#include &lt;bits/stdc++.h&gt;using namespace std;int a,b,c;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;max(max(max(max(max(a*b*c,a+b+c),a*(b+c)),(a+b)*c),a+b*c),a*b+c);//恶心的5个max连求&#125; 别问我为什么题解这么短，因为真的没什么好说的]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[省赛之旅]]></title>
    <url>%2F2019%2F01%2F12%2F%E7%9C%81%E8%B5%9B%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[我要写一篇省赛的游记 Day1周四。晚上疯狂地写完作业，到洛谷上颓了2小时。哎，明天就走，不能不刷题了，何况还报了高中。 Day2周五上午早上下起了小雨，心情有点忧伤。本来请的是下午的假，现在因为怕堵车把上午3、4两节也请了。后来才发现我逃了一个听写 第三节英语课。果断地收拾书包离开，先跟英语老师再见，然后觉得这样走很奇怪，于是又跟同学们再见了一下。英语老师说我有领导气质？什么鬼……只是模仿领导人挥了一下手而已 中午没有事，吃完就出发了。下午到了省城。仍然是工作人员找不到准考证 试机先试高中组。旁边两个大佬的对话如下： 大佬A：昨天写了一个网络流。你说我要不要再写一遍？ 大佬B：早上写了一个费用流，我觉得我不一定能AK 我在一旁被完全碾压 初中组就完全不一样了 一群人大喊：啊，这个DP怎么这么难啊 别人：我要不要写一个DP呢？ 我：哼。DP？多简单啊，反正我有模板……我还是研究一下随机数算法吧。然而编译并没有过…… 晚上回宾馆颓 Day3周六上午AHOI高中组本来是7：40进考场，但是由于要排队，竟然拖到8:05还没有进考场。 好不容易进了，然后发现发了一个假的zip？ 传说中的 .7z文件！什么鬼…… 先打第一题。疯狂地打了98行的找规律，最后发现愉快的WA了。 果断改成递归。 此时已过去2hours。 第二题本来以为很难，环形模拟？40分get 第三题根本看不懂，于是愉快地递归 此三题在洛谷上： 估分：30+40+30=100 实际：？+？+？=30 下午AHOI初中组前三题愉快地AC了样例，开始做最后一题 此时还剩2：55分 结果是，第四题拿了30分质数点后，手打字典序，可惜我忘了STL那个命令叫什么。 于是估分100+100+100+30=330 结果：100+0+30+0=130 晚上回宾馆发现我橙了 Day4上午仍然是搞事情的.7z文件 结果，我打了一个第一题的模拟，可能得了30分。 回去发现两天加起来才60分。。。 我还是太渣了，回去练练吧。 谨以此纪念我逝去的初一OI]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018颓废之路]]></title>
    <url>%2F2019%2F01%2F12%2FNOIP2018%E9%A2%93%E5%BA%9F%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[初赛上午颓了一上午有题。然后，什么资料没看，装作都懂的样子。 下午进考点，与一个同学一起挤到前面，身后一群27中的占领了整条路。。。这就是搞OI和不搞OI的学校的区别吧。。。 进考场，我很淡定的答题，完了4：00就写完了。于是检查结果改错了一道8分的题，听说不给带试卷，于是机智的我将答案抄到了我的课表上算不算作弊啊，出考场，对答案，还好，75，应该能过了。 晚上上洛谷颓，结果被3个巨佬吊打，果断走了。 10.16上午学校指导老师亲自找我，我一脸懵：我怎么就71？？？ 然而还是过了线，而且我们学校只有两个人过了线 11.9下午上机。旁边坐这一个淮南的小学生一口方言，还啥都不知道，说起来都5年级了。长得像个1年级的 在中心考场，最后一个座位？？？试机打了个线段树，竟然打炸了…… 回洛谷把二分图匹配水过去了，然后发了一篇题解攒RP。 祝NOIP2018RP++！ 11.10上午一觉睡到10点多，起来，到洛谷上颓了一会，然后吃饭后被逼去写作业了。。。 下午1:50到考点。我在第10考场，结果第10考场的牌子都没举起来？？？害我找半天 跟着大部队，到了考场，发现同校的巨佬@柳暗花明 没来？然而还是来了 发密码了。看到密码的时候，我整个人都惊了：密码这么简单，我怎么没猜到？ 没错，就是这个密码： 12&amp;GaiGeKaiFang(40)Nian（改革开放40年） 可见OI有时是与政治相关的…… 解开，看第1题……竟然卡了好久，因为看到输入可能包含数字、字母、空格和换行符，想了半天还能有啥？然后就把这几个判了，还好，会谷一测对了。 T2把我吓到了…… 我果断开始暴力模拟，终于过了2个小样例…… 然而，大样例WA了！！！ 我立刻开始慌…… 然后想到洛谷11月月赛给我的教训： 三年OI一场空，不开long long见祖宗于是果断加了long long，还好，过了 看到T3，我又疯了…… 怎么T3就上DP了！！！果断去看T4 然而看了之后 我还是去打T3吧 我使尽所有智力，打出一个DP。 我修改了一下，结果 机子死机了！NOI Linux系统差评 NOIP 机房差评 把监考老师喊来，重启，好不容易进了系统，guide又崩了…… guide差评 无奈的我只好到旁边去考了……f**k！ 拷程序的时候死慢，我的程序当时是不小心写成了死循环，结果运行文件2.2G……系统被我搞坏了，溜了溜了 换新机子成功打完了T3……然而大样例WA了……考场上实在调不出来，于是又转头去攻T4了 T4先开始信心满满，越打越不会，最后放弃了，拿了3个点，还有一个神奇的rand 剩下来的时间颓废 收程序的时候，我旁边那个小朋友的程序我看到了 怪不得他写那么快！他T1写了个title.cpp输出第1个样例，title.cpp2输出第2给样例，第3个没输出…… 4题都这样 我的内心：仰望高端玩家 11.11上午上谷测了一下，264，慌的要死其实后来官方数据把我卡到了210 大概要退役了吧 明年的省赛不打算参加了，打算好好搞文化课，所以 谨记我逝去的初二OI！也祝大家能获得一个好成绩 另：如果你真的爱OI，一定要到一个重视OI的学校去啊！]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
